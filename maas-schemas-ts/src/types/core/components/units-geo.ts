/*

undefined
MaaS common geolocaion units that are used consistently within our own objects

!!! AUTO GENERATED BY IOTSFJS REFRAIN FROM MANUAL EDITING !!!
See https://www.npmjs.com/package/io-ts-from-json-schema

*/

import * as t from 'io-ts';

type Defined =
  | Record<string, unknown>
  | Array<unknown>
  | string
  | boolean
  | number
  | null;
const Defined = t.union([
  t.UnknownRecord,
  t.UnknownArray,
  t.string,
  t.boolean,
  t.number,
  t.null,
]);

export const schemaId = 'http://maasglobal.com/core/components/units-geo.json';

// Latitude
// Geographic latitude (north-south axis) in WGS-84 system, see https://en.wikipedia.org/wiki/World_Geodetic_System
export type Latitude = t.Branded<number, LatitudeBrand>;
export const Latitude = t.brand(
  t.number,
  (x): x is t.Branded<number, LatitudeBrand> =>
    (typeof x !== 'number' || x >= -90) && (typeof x !== 'number' || x <= 90),
  'Latitude',
);
export interface LatitudeBrand {
  readonly Latitude: unique symbol;
}

// Longitude
// Geographic longitude (east-west axis) in WGS-84 system, see https://en.wikipedia.org/wiki/World_Geodetic_System
export type Longitude = t.Branded<number, LongitudeBrand>;
export const Longitude = t.brand(
  t.number,
  (x): x is t.Branded<number, LongitudeBrand> =>
    (typeof x !== 'number' || x >= -180) && (typeof x !== 'number' || x <= 180),
  'Longitude',
);
export interface LongitudeBrand {
  readonly Longitude: unique symbol;
}

// RelaxedLatitude
// No-numeric precision version of MaaS core latitude
export type RelaxedLatitude = t.Branded<number, RelaxedLatitudeBrand>;
export const RelaxedLatitude = t.brand(
  t.number,
  (x): x is t.Branded<number, RelaxedLatitudeBrand> =>
    (typeof x !== 'number' || x >= -90) && (typeof x !== 'number' || x <= 90),
  'RelaxedLatitude',
);
export interface RelaxedLatitudeBrand {
  readonly RelaxedLatitude: unique symbol;
}

// RelaxedLongitude
// No-numeric precision version of MaaS core longitude
export type RelaxedLongitude = t.Branded<number, RelaxedLongitudeBrand>;
export const RelaxedLongitude = t.brand(
  t.number,
  (x): x is t.Branded<number, RelaxedLongitudeBrand> =>
    (typeof x !== 'number' || x >= -180) && (typeof x !== 'number' || x <= 180),
  'RelaxedLongitude',
);
export interface RelaxedLongitudeBrand {
  readonly RelaxedLongitude: unique symbol;
}

// Distance
// Distance in meters
export type Distance = t.Branded<number, DistanceBrand>;
export const Distance = t.brand(
  t.number,
  (x): x is t.Branded<number, DistanceBrand> =>
    (typeof x !== 'number' || x <= 40075000) && (typeof x !== 'number' || x % 1 === 0),
  'Distance',
);
export interface DistanceBrand {
  readonly Distance: unique symbol;
}

// Polyline
// Google encoded polyline, see: https://developers.google.com/maps/documentation/utilities/polylinealgorithm
export type Polyline = t.Branded<string, PolylineBrand>;
export const Polyline = t.brand(
  t.string,
  (x): x is t.Branded<string, PolylineBrand> =>
    (typeof x !== 'string' ||
      x.match(RegExp('^([\\x5F-\\x7E]*[\\x3F-\\x5E])+$')) !== null) &&
    (typeof x !== 'string' || x.length >= 3) &&
    (typeof x !== 'string' || x.length <= 65535),
  'Polyline',
);
export interface PolylineBrand {
  readonly Polyline: unique symbol;
}

// Location
// Geographic latitude-longitude object in WGS-84 system, see https://en.wikipedia.org/wiki/World_Geodetic_System
export type Location = t.Branded<
  {
    lat?: Latitude;
    lon?: Longitude;
  } & {
    lat: Defined;
    lon: Defined;
  },
  LocationBrand
>;
export const Location = t.brand(
  t.intersection([
    t.partial({
      lat: Latitude,
      lon: Longitude,
    }),
    t.type({
      lat: Defined,
      lon: Defined,
    }),
  ]),
  (
    x,
  ): x is t.Branded<
    {
      lat?: Latitude;
      lon?: Longitude;
    } & {
      lat: Defined;
      lon: Defined;
    },
    LocationBrand
  > => true,
  'Location',
);
export interface LocationBrand {
  readonly Location: unique symbol;
}

// RelaxedLocation
// No-numeric precision version of MaaS core location
export type RelaxedLocation = t.Branded<
  {
    lat?: RelaxedLatitude;
    lon?: RelaxedLongitude;
  } & {
    lat: Defined;
    lon: Defined;
  },
  RelaxedLocationBrand
>;
export const RelaxedLocation = t.brand(
  t.intersection([
    t.partial({
      lat: RelaxedLatitude,
      lon: RelaxedLongitude,
    }),
    t.type({
      lat: Defined,
      lon: Defined,
    }),
  ]),
  (
    x,
  ): x is t.Branded<
    {
      lat?: RelaxedLatitude;
      lon?: RelaxedLongitude;
    } & {
      lat: Defined;
      lon: Defined;
    },
    RelaxedLocationBrand
  > => true,
  'RelaxedLocation',
);
export interface RelaxedLocationBrand {
  readonly RelaxedLocation: unique symbol;
}

// ShortLocation
// Geographic latitude-longitude number-pair array in WGS-84 system, see https://en.wikipedia.org/wiki/World_Geodetic_System
export type ShortLocation = t.Branded<[Latitude, Longitude], ShortLocationBrand>;
export const ShortLocation = t.brand(
  t.tuple([Latitude, Longitude]),
  (x): x is t.Branded<[Latitude, Longitude], ShortLocationBrand> => true,
  'ShortLocation',
);
export interface ShortLocationBrand {
  readonly ShortLocation: unique symbol;
}

// ShortLocationString
// Geographic latitude-longitude number-pair as a string in WGS-84 system, see https://en.wikipedia.org/wiki/World_Geodetic_System
export type ShortLocationString = t.Branded<string, ShortLocationStringBrand>;
export const ShortLocationString = t.brand(
  t.string,
  (x): x is t.Branded<string, ShortLocationStringBrand> =>
    (typeof x !== 'string' ||
      x.match(RegExp('^[+-]?\\d{1,3}(\\.\\d+)?,[+-]?\\d{1,3}(\\.\\d+)?$')) !== null) &&
    (typeof x !== 'string' || x.length >= 1) &&
    (typeof x !== 'string' || x.length <= 64),
  'ShortLocationString',
);
export interface ShortLocationStringBrand {
  readonly ShortLocationString: unique symbol;
}

// UnitsGeo
// The default export. More information at the top.
export type UnitsGeo = t.Branded<unknown, UnitsGeoBrand>;
export const UnitsGeo = t.brand(
  t.unknown,
  (x): x is t.Branded<unknown, UnitsGeoBrand> => true,
  'UnitsGeo',
);
export interface UnitsGeoBrand {
  readonly UnitsGeo: unique symbol;
}

export default UnitsGeo;

// Success
