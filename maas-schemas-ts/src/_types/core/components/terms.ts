/*

undefined
MaaS booking terms and condition for its business engine

!!! AUTO GENERATED BY IOTSFJS REFRAIN FROM MANUAL EDITING !!!
See https://www.npmjs.com/package/io-ts-from-json-schema

*/

import * as t from 'io-ts';
import * as Cost_ from './cost';
import * as Fare_ from './fare';
import * as Units_ from './units';
import * as State_ from './state';

export type Defined = {} | null;
export class DefinedType extends t.Type<Defined> {
  readonly _tag: 'DefinedType' = 'DefinedType';
  constructor() {
    super(
      'defined',
      (u): u is Defined => typeof u !== 'undefined',
      (u, c) => (this.is(u) ? t.success(u) : t.failure(u, c)),
      t.identity,
    );
  }
}
export interface DefinedC extends DefinedType {}
export const Defined: DefinedC = new DefinedType();

export const schemaId = 'https://schemas.maas.global/core/components/terms.json';

// Seat
// Ticket's seat information for long distance trains, coaches or flights
export type Seat = t.Branded<
  {
    route?: string;
    number?: string | number;
    coach?: string | number;
  } & Record<string, unknown>,
  SeatBrand
>;
export type SeatC = t.BrandC<
  t.IntersectionC<
    [
      t.PartialC<{
        route: t.StringC;
        number: t.UnionC<[t.StringC, t.NumberC]>;
        coach: t.UnionC<[t.StringC, t.NumberC]>;
      }>,
      t.RecordC<t.StringC, t.UnknownC>,
    ]
  >,
  SeatBrand
>;
export const Seat: SeatC = t.brand(
  t.intersection([
    t.partial({
      route: t.string,
      number: t.union([t.string, t.number]),
      coach: t.union([t.string, t.number]),
    }),
    t.record(t.string, t.unknown),
  ]),
  (
    x,
  ): x is t.Branded<
    {
      route?: string;
      number?: string | number;
      coach?: string | number;
    } & Record<string, unknown>,
    SeatBrand
  > => true,
  'Seat',
);
export interface SeatBrand {
  readonly Seat: unique symbol;
}

// Cancellation
// The purpose of this remains a mystery
export type Cancellation = t.Branded<
  ({
    cancellable?: boolean;
    cost?: Cost_.Cost;
    fare?: Fare_.Fare;
    refunded?: boolean;
    validity?: ({
      startTime?: Units_.Time;
      endTime?: Units_.Time;
    } & Record<string, unknown>) & {
      endTime: Defined;
    };
  } & Record<string, unknown>) & {
    cancellable: Defined;
    refunded: Defined;
  },
  CancellationBrand
>;
export type CancellationC = t.BrandC<
  t.IntersectionC<
    [
      t.IntersectionC<
        [
          t.PartialC<{
            cancellable: t.BooleanC;
            cost: typeof Cost_.Cost;
            fare: typeof Fare_.Fare;
            refunded: t.BooleanC;
            validity: t.IntersectionC<
              [
                t.IntersectionC<
                  [
                    t.PartialC<{
                      startTime: typeof Units_.Time;
                      endTime: typeof Units_.Time;
                    }>,
                    t.RecordC<t.StringC, t.UnknownC>,
                  ]
                >,
                t.TypeC<{
                  endTime: typeof Defined;
                }>,
              ]
            >;
          }>,
          t.RecordC<t.StringC, t.UnknownC>,
        ]
      >,
      t.TypeC<{
        cancellable: typeof Defined;
        refunded: typeof Defined;
      }>,
    ]
  >,
  CancellationBrand
>;
export const Cancellation: CancellationC = t.brand(
  t.intersection([
    t.intersection([
      t.partial({
        cancellable: t.boolean,
        cost: Cost_.Cost,
        fare: Fare_.Fare,
        refunded: t.boolean,
        validity: t.intersection([
          t.intersection([
            t.partial({
              startTime: Units_.Time,
              endTime: Units_.Time,
            }),
            t.record(t.string, t.unknown),
          ]),
          t.type({
            endTime: Defined,
          }),
        ]),
      }),
      t.record(t.string, t.unknown),
    ]),
    t.type({
      cancellable: Defined,
      refunded: Defined,
    }),
  ]),
  (
    x,
  ): x is t.Branded<
    ({
      cancellable?: boolean;
      cost?: Cost_.Cost;
      fare?: Fare_.Fare;
      refunded?: boolean;
      validity?: ({
        startTime?: Units_.Time;
        endTime?: Units_.Time;
      } & Record<string, unknown>) & {
        endTime: Defined;
      };
    } & Record<string, unknown>) & {
      cancellable: Defined;
      refunded: Defined;
    },
    CancellationBrand
  > => true,
  'Cancellation',
);
export interface CancellationBrand {
  readonly Cancellation: unique symbol;
}

// Amendment
// The purpose of this remains a mystery
export type Amendment = t.Branded<
  ({
    amendable?: boolean;
    cost?: Cost_.Cost;
    fare?: Fare_.Fare;
  } & Record<string, unknown>) & {
    amendable: Defined;
  },
  AmendmentBrand
>;
export type AmendmentC = t.BrandC<
  t.IntersectionC<
    [
      t.IntersectionC<
        [
          t.PartialC<{
            amendable: t.BooleanC;
            cost: typeof Cost_.Cost;
            fare: typeof Fare_.Fare;
          }>,
          t.RecordC<t.StringC, t.UnknownC>,
        ]
      >,
      t.TypeC<{
        amendable: typeof Defined;
      }>,
    ]
  >,
  AmendmentBrand
>;
export const Amendment: AmendmentC = t.brand(
  t.intersection([
    t.intersection([
      t.partial({
        amendable: t.boolean,
        cost: Cost_.Cost,
        fare: Fare_.Fare,
      }),
      t.record(t.string, t.unknown),
    ]),
    t.type({
      amendable: Defined,
    }),
  ]),
  (
    x,
  ): x is t.Branded<
    ({
      amendable?: boolean;
      cost?: Cost_.Cost;
      fare?: Fare_.Fare;
    } & Record<string, unknown>) & {
      amendable: Defined;
    },
    AmendmentBrand
  > => true,
  'Amendment',
);
export interface AmendmentBrand {
  readonly Amendment: unique symbol;
}

// Surcharge
// The additional fee that will be added if booking is in night time
export type Surcharge = t.Branded<
  {
    isChargedUpfront?: boolean;
    amount?: number;
    currency?: Units_.Currency;
    percentage?: number;
    minAmount?: number;
    maxAmount?: number;
  },
  SurchargeBrand
>;
export type SurchargeC = t.BrandC<
  t.PartialC<{
    isChargedUpfront: t.BooleanC;
    amount: t.NumberC;
    currency: typeof Units_.Currency;
    percentage: t.NumberC;
    minAmount: t.NumberC;
    maxAmount: t.NumberC;
  }>,
  SurchargeBrand
>;
export const Surcharge: SurchargeC = t.brand(
  t.partial({
    isChargedUpfront: t.boolean,
    amount: t.number,
    currency: Units_.Currency,
    percentage: t.number,
    minAmount: t.number,
    maxAmount: t.number,
  }),
  (
    x,
  ): x is t.Branded<
    {
      isChargedUpfront?: boolean;
      amount?: number;
      currency?: Units_.Currency;
      percentage?: number;
      minAmount?: number;
      maxAmount?: number;
    },
    SurchargeBrand
  > => true,
  'Surcharge',
);
export interface SurchargeBrand {
  readonly Surcharge: unique symbol;
}

// Terms
// The default export. More information at the top.
export type Terms = t.Branded<
  {
    type?: string;
    seatings?: Array<Seat>;
    validity?: ({
      startTime?: Units_.Time;
      endTime?: Units_.Time;
      startTimeReturn?: Units_.Time;
      endTimeReturn?: Units_.Time;
    } & Record<string, unknown>) & {
      startTime: Defined;
      endTime: Defined;
    };
    reusable?: boolean;
    reconcilable?: boolean;
    restrictions?: {
      singleDevice?: boolean;
      skipRestrictionCheck?: boolean;
      freeTicket?: Record<string, unknown> & Record<string, unknown>;
      forbidMultipleBookingsActive?: boolean;
    } & Record<string, unknown>;
    surcharges?: {
      midnight?: Surcharge;
      pickup?: Surcharge;
    } & Record<string, unknown>;
    cancellation?: {
      counter?: {
        time?: number;
        fromState?: State_.BookingState;
      } & Record<string, unknown>;
      cancellationFormActionUrl?: Units_.Url;
      outward?: Cancellation;
      return?: Cancellation;
    } & Record<string, unknown>;
    amendment?: {
      outward?: Amendment;
      return?: Amendment;
    } & Record<string, unknown>;
    prePurchaseGuidanceUrl?: Units_.Url;
    fareRates?: Array<
      ({
        amount?: number;
        currency?: Units_.CurrencyOrToken;
        timeInterval?: number;
        startAt?: number;
        type?:
          | 'maxRate'
          | 'missedReturnPenalty'
          | 'extra'
          | 'perKilometer'
          | 'perParkMinute'
          | 'unlockFee';
      } & Record<string, unknown>) & {
        amount: Defined;
        currency: Defined;
      }
    >;
  } & Record<string, unknown>,
  TermsBrand
>;
export type TermsC = t.BrandC<
  t.IntersectionC<
    [
      t.PartialC<{
        type: t.StringC;
        seatings: t.ArrayC<typeof Seat>;
        validity: t.IntersectionC<
          [
            t.IntersectionC<
              [
                t.PartialC<{
                  startTime: typeof Units_.Time;
                  endTime: typeof Units_.Time;
                  startTimeReturn: typeof Units_.Time;
                  endTimeReturn: typeof Units_.Time;
                }>,
                t.RecordC<t.StringC, t.UnknownC>,
              ]
            >,
            t.TypeC<{
              startTime: typeof Defined;
              endTime: typeof Defined;
            }>,
          ]
        >;
        reusable: t.BooleanC;
        reconcilable: t.BooleanC;
        restrictions: t.IntersectionC<
          [
            t.PartialC<{
              singleDevice: t.BooleanC;
              skipRestrictionCheck: t.BooleanC;
              freeTicket: t.IntersectionC<
                [t.UnknownRecordC, t.RecordC<t.StringC, t.UnknownC>]
              >;
              forbidMultipleBookingsActive: t.BooleanC;
            }>,
            t.RecordC<t.StringC, t.UnknownC>,
          ]
        >;
        surcharges: t.IntersectionC<
          [
            t.PartialC<{
              midnight: typeof Surcharge;
              pickup: typeof Surcharge;
            }>,
            t.RecordC<t.StringC, t.UnknownC>,
          ]
        >;
        cancellation: t.IntersectionC<
          [
            t.PartialC<{
              counter: t.IntersectionC<
                [
                  t.PartialC<{
                    time: t.NumberC;
                    fromState: typeof State_.BookingState;
                  }>,
                  t.RecordC<t.StringC, t.UnknownC>,
                ]
              >;
              cancellationFormActionUrl: typeof Units_.Url;
              outward: typeof Cancellation;
              return: typeof Cancellation;
            }>,
            t.RecordC<t.StringC, t.UnknownC>,
          ]
        >;
        amendment: t.IntersectionC<
          [
            t.PartialC<{
              outward: typeof Amendment;
              return: typeof Amendment;
            }>,
            t.RecordC<t.StringC, t.UnknownC>,
          ]
        >;
        prePurchaseGuidanceUrl: typeof Units_.Url;
        fareRates: t.ArrayC<
          t.IntersectionC<
            [
              t.IntersectionC<
                [
                  t.PartialC<{
                    amount: t.NumberC;
                    currency: typeof Units_.CurrencyOrToken;
                    timeInterval: t.NumberC;
                    startAt: t.NumberC;
                    type: t.UnionC<
                      [
                        t.LiteralC<'maxRate'>,
                        t.LiteralC<'missedReturnPenalty'>,
                        t.LiteralC<'extra'>,
                        t.LiteralC<'perKilometer'>,
                        t.LiteralC<'perParkMinute'>,
                        t.LiteralC<'unlockFee'>,
                      ]
                    >;
                  }>,
                  t.RecordC<t.StringC, t.UnknownC>,
                ]
              >,
              t.TypeC<{
                amount: typeof Defined;
                currency: typeof Defined;
              }>,
            ]
          >
        >;
      }>,
      t.RecordC<t.StringC, t.UnknownC>,
    ]
  >,
  TermsBrand
>;
export const Terms: TermsC = t.brand(
  t.intersection([
    t.partial({
      type: t.string,
      seatings: t.array(Seat),
      validity: t.intersection([
        t.intersection([
          t.partial({
            startTime: Units_.Time,
            endTime: Units_.Time,
            startTimeReturn: Units_.Time,
            endTimeReturn: Units_.Time,
          }),
          t.record(t.string, t.unknown),
        ]),
        t.type({
          startTime: Defined,
          endTime: Defined,
        }),
      ]),
      reusable: t.boolean,
      reconcilable: t.boolean,
      restrictions: t.intersection([
        t.partial({
          singleDevice: t.boolean,
          skipRestrictionCheck: t.boolean,
          freeTicket: t.intersection([t.UnknownRecord, t.record(t.string, t.unknown)]),
          forbidMultipleBookingsActive: t.boolean,
        }),
        t.record(t.string, t.unknown),
      ]),
      surcharges: t.intersection([
        t.partial({
          midnight: Surcharge,
          pickup: Surcharge,
        }),
        t.record(t.string, t.unknown),
      ]),
      cancellation: t.intersection([
        t.partial({
          counter: t.intersection([
            t.partial({
              time: t.number,
              fromState: State_.BookingState,
            }),
            t.record(t.string, t.unknown),
          ]),
          cancellationFormActionUrl: Units_.Url,
          outward: Cancellation,
          return: Cancellation,
        }),
        t.record(t.string, t.unknown),
      ]),
      amendment: t.intersection([
        t.partial({
          outward: Amendment,
          return: Amendment,
        }),
        t.record(t.string, t.unknown),
      ]),
      prePurchaseGuidanceUrl: Units_.Url,
      fareRates: t.array(
        t.intersection([
          t.intersection([
            t.partial({
              amount: t.number,
              currency: Units_.CurrencyOrToken,
              timeInterval: t.number,
              startAt: t.number,
              type: t.union([
                t.literal('maxRate'),
                t.literal('missedReturnPenalty'),
                t.literal('extra'),
                t.literal('perKilometer'),
                t.literal('perParkMinute'),
                t.literal('unlockFee'),
              ]),
            }),
            t.record(t.string, t.unknown),
          ]),
          t.type({
            amount: Defined,
            currency: Defined,
          }),
        ]),
      ),
    }),
    t.record(t.string, t.unknown),
  ]),
  (
    x,
  ): x is t.Branded<
    {
      type?: string;
      seatings?: Array<Seat>;
      validity?: ({
        startTime?: Units_.Time;
        endTime?: Units_.Time;
        startTimeReturn?: Units_.Time;
        endTimeReturn?: Units_.Time;
      } & Record<string, unknown>) & {
        startTime: Defined;
        endTime: Defined;
      };
      reusable?: boolean;
      reconcilable?: boolean;
      restrictions?: {
        singleDevice?: boolean;
        skipRestrictionCheck?: boolean;
        freeTicket?: Record<string, unknown> & Record<string, unknown>;
        forbidMultipleBookingsActive?: boolean;
      } & Record<string, unknown>;
      surcharges?: {
        midnight?: Surcharge;
        pickup?: Surcharge;
      } & Record<string, unknown>;
      cancellation?: {
        counter?: {
          time?: number;
          fromState?: State_.BookingState;
        } & Record<string, unknown>;
        cancellationFormActionUrl?: Units_.Url;
        outward?: Cancellation;
        return?: Cancellation;
      } & Record<string, unknown>;
      amendment?: {
        outward?: Amendment;
        return?: Amendment;
      } & Record<string, unknown>;
      prePurchaseGuidanceUrl?: Units_.Url;
      fareRates?: Array<
        ({
          amount?: number;
          currency?: Units_.CurrencyOrToken;
          timeInterval?: number;
          startAt?: number;
          type?:
            | 'maxRate'
            | 'missedReturnPenalty'
            | 'extra'
            | 'perKilometer'
            | 'perParkMinute'
            | 'unlockFee';
        } & Record<string, unknown>) & {
          amount: Defined;
          currency: Defined;
        }
      >;
    } & Record<string, unknown>,
    TermsBrand
  > => true,
  'Terms',
);
export interface TermsBrand {
  readonly Terms: unique symbol;
}

export default Terms;

// Success
