/*

undefined
MaaS common units that are used consistently within our own objects

!!! AUTO GENERATED BY IOTSFJS REFRAIN FROM MANUAL EDITING !!!
See https://www.npmjs.com/package/io-ts-from-json-schema

*/

import * as t from 'io-ts';
import { NonEmptyArray } from 'fp-ts/lib/NonEmptyArray';
import { nonEmptyArray } from 'io-ts-types/lib/nonEmptyArray';

export const schemaId = 'https://schemas.maas.global/core/components/units.json';

// Uuid
// Universally unique identifier, see https://en.wikipedia.org/wiki/Universally_unique_identifier
export type Uuid = t.Branded<string, UuidBrand>;
export type UuidC = t.BrandC<t.StringC, UuidBrand>;
export const Uuid: UuidC = t.brand(
  t.string,
  (x): x is t.Branded<string, UuidBrand> =>
    typeof x !== 'string' ||
    x.match(RegExp('^[A-Fa-f0-9]{8}(-[A-Fa-f0-9]{4}){3}-[A-Fa-f0-9]{12}$')) !== null,
  'Uuid',
);
export interface UuidBrand {
  readonly Uuid: unique symbol;
}
/** require('io-ts-validator').validator(nonEmptyArray(Uuid)).decodeSync(examplesUuid) // => examplesUuid */
export const examplesUuid: NonEmptyArray<Uuid> = ([
  '4828507e-683f-41bf-9d87-689808fbf958',
] as unknown) as NonEmptyArray<Uuid>;

// HostnameLabel
// single component of a hostname
export type HostnameLabel = t.Branded<string, HostnameLabelBrand>;
export type HostnameLabelC = t.BrandC<t.StringC, HostnameLabelBrand>;
export const HostnameLabel: HostnameLabelC = t.brand(
  t.string,
  (x): x is t.Branded<string, HostnameLabelBrand> =>
    (typeof x !== 'string' ||
      x.match(RegExp('^[a-z0-9]([-a-z0-9]{0,61}[a-z0-9])?$')) !== null) &&
    (typeof x !== 'string' || x.length >= 1) &&
    (typeof x !== 'string' || x.length <= 63),
  'HostnameLabel',
);
export interface HostnameLabelBrand {
  readonly HostnameLabel: unique symbol;
}
/** require('io-ts-validator').validator(nonEmptyArray(HostnameLabel)).decodeSync(examplesHostnameLabel) // => examplesHostnameLabel */
export const examplesHostnameLabel: NonEmptyArray<HostnameLabel> = ([
  'example',
  'com',
  'with-hyphen',
  'foo1',
  '0bar',
] as unknown) as NonEmptyArray<HostnameLabel>;

// HostnameDelimiter
// The purpose of this remains a mystery
export type HostnameDelimiter = t.Branded<string & '.', HostnameDelimiterBrand>;
export type HostnameDelimiterC = t.BrandC<
  t.IntersectionC<[t.StringC, t.LiteralC<'.'>]>,
  HostnameDelimiterBrand
>;
export const HostnameDelimiter: HostnameDelimiterC = t.brand(
  t.intersection([t.string, t.literal('.')]),
  (x): x is t.Branded<string & '.', HostnameDelimiterBrand> => true,
  'HostnameDelimiter',
);
export interface HostnameDelimiterBrand {
  readonly HostnameDelimiter: unique symbol;
}
/** require('io-ts-validator').validator(HostnameDelimiter).decodeSync(defaultHostnameDelimiter) // => defaultHostnameDelimiter */
export const defaultHostnameDelimiter: HostnameDelimiter = ('.' as unknown) as HostnameDelimiter;

// Hostname
// list of 1 or more hostname labels separated by hostname delimiter
export type Hostname = t.Branded<string, HostnameBrand>;
export type HostnameC = t.BrandC<t.StringC, HostnameBrand>;
export const Hostname: HostnameC = t.brand(
  t.string,
  (x): x is t.Branded<string, HostnameBrand> =>
    (typeof x !== 'string' ||
      x.match(
        RegExp(
          '^[a-z0-9]([-a-z0-9]{0,61}[a-z0-9])?(.[a-z0-9]([-a-z0-9]{0,61}[a-z0-9])?)*$',
        ),
      ) !== null) &&
    (typeof x !== 'string' || x.length >= 1) &&
    (typeof x !== 'string' || x.length <= 253),
  'Hostname',
);
export interface HostnameBrand {
  readonly Hostname: unique symbol;
}
/** require('io-ts-validator').validator(nonEmptyArray(Hostname)).decodeSync(examplesHostname) // => examplesHostname */
export const examplesHostname: NonEmptyArray<Hostname> = ([
  'localhost',
  'example.com',
  'sub.example.com',
] as unknown) as NonEmptyArray<Hostname>;

// Port
// Transport layer port number ( 0- ). Most likely TCP or UDP port ( 0-65535 ).
export type Port = t.Branded<number, PortBrand>;
export type PortC = t.BrandC<t.NumberC, PortBrand>;
export const Port: PortC = t.brand(
  t.number,
  (x): x is t.Branded<number, PortBrand> => typeof x !== 'number' || x % 1 === 0,
  'Port',
);
export interface PortBrand {
  readonly Port: unique symbol;
}
/** require('io-ts-validator').validator(Port).decodeSync(minimumPort) // => minimumPort */
export const minimumPort: Port = (0 as unknown) as Port;

// HostPortDelimiter
// The purpose of this remains a mystery
export type HostPortDelimiter = t.Branded<string & ':', HostPortDelimiterBrand>;
export type HostPortDelimiterC = t.BrandC<
  t.IntersectionC<[t.StringC, t.LiteralC<':'>]>,
  HostPortDelimiterBrand
>;
export const HostPortDelimiter: HostPortDelimiterC = t.brand(
  t.intersection([t.string, t.literal(':')]),
  (x): x is t.Branded<string & ':', HostPortDelimiterBrand> => true,
  'HostPortDelimiter',
);
export interface HostPortDelimiterBrand {
  readonly HostPortDelimiter: unique symbol;
}
/** require('io-ts-validator').validator(HostPortDelimiter).decodeSync(defaultHostPortDelimiter) // => defaultHostPortDelimiter */
export const defaultHostPortDelimiter: HostPortDelimiter = (':' as unknown) as HostPortDelimiter;

// Authority
// HTTP2 :authority <hostname>[:<port>] https://tools.ietf.org/html/rfc7540#section-8.1.2.3
export type Authority = t.Branded<string, AuthorityBrand>;
export type AuthorityC = t.BrandC<t.StringC, AuthorityBrand>;
export const Authority: AuthorityC = t.brand(
  t.string,
  (x): x is t.Branded<string, AuthorityBrand> =>
    typeof x !== 'string' ||
    x.match(
      RegExp(
        '^[a-z0-9]([-a-z0-9]{0,61}[a-z0-9])?(.[a-z0-9]([-a-z0-9]{0,61}[a-z0-9])?)*(:(0|1[0-9]*))?$',
      ),
    ) !== null,
  'Authority',
);
export interface AuthorityBrand {
  readonly Authority: unique symbol;
}
/** require('io-ts-validator').validator(nonEmptyArray(Authority)).decodeSync(examplesAuthority) // => examplesAuthority */
export const examplesAuthority: NonEmptyArray<Authority> = ([
  'env.application.example.com:123',
  'env.application.example.com',
] as unknown) as NonEmptyArray<Authority>;

// NetworkSchemeDelimiter
// The purpose of this remains a mystery
export type NetworkSchemeDelimiter = t.Branded<
  string & '://',
  NetworkSchemeDelimiterBrand
>;
export type NetworkSchemeDelimiterC = t.BrandC<
  t.IntersectionC<[t.StringC, t.LiteralC<'://'>]>,
  NetworkSchemeDelimiterBrand
>;
export const NetworkSchemeDelimiter: NetworkSchemeDelimiterC = t.brand(
  t.intersection([t.string, t.literal('://')]),
  (x): x is t.Branded<string & '://', NetworkSchemeDelimiterBrand> => true,
  'NetworkSchemeDelimiter',
);
export interface NetworkSchemeDelimiterBrand {
  readonly NetworkSchemeDelimiter: unique symbol;
}
/** require('io-ts-validator').validator(NetworkSchemeDelimiter).decodeSync(defaultNetworkSchemeDelimiter) // => defaultNetworkSchemeDelimiter */
export const defaultNetworkSchemeDelimiter: NetworkSchemeDelimiter = ('://' as unknown) as NetworkSchemeDelimiter;

// Url
// Uniform resource locator, see https://en.wikipedia.org/wiki/Uniform_Resource_Locator and https://mathiasbynens.be/demo/url-regex
export type Url = t.Branded<string, UrlBrand>;
export type UrlC = t.BrandC<t.StringC, UrlBrand>;
export const Url: UrlC = t.brand(
  t.string,
  (x): x is t.Branded<string, UrlBrand> =>
    typeof x !== 'string' ||
    x.match(RegExp('^(https?|ftp):\\/\\/[^\\s/$.?#].[^\\s]*$')) !== null,
  'Url',
);
export interface UrlBrand {
  readonly Url: unique symbol;
}

// Arn
// The purpose of this remains a mystery
export type Arn = t.Branded<string, ArnBrand>;
export type ArnC = t.BrandC<t.StringC, ArnBrand>;
export const Arn: ArnC = t.brand(
  t.string,
  (x): x is t.Branded<string, ArnBrand> =>
    (typeof x !== 'string' ||
      x.match(
        RegExp('^arn:aws:[a-z]+:[\\w\\-]*:\\d{12}:[ \\w\\-]+(\\/[\\w\\- \\/]+)*'),
      ) !== null) &&
    (typeof x !== 'string' || x.length >= 1) &&
    (typeof x !== 'string' || x.length <= 256),
  'Arn',
);
export interface ArnBrand {
  readonly Arn: unique symbol;
}

// ObsoleteIdentityId
// The purpose of this remains a mystery
export type ObsoleteIdentityId = t.Branded<string, ObsoleteIdentityIdBrand>;
export type ObsoleteIdentityIdC = t.BrandC<t.StringC, ObsoleteIdentityIdBrand>;
export const ObsoleteIdentityId: ObsoleteIdentityIdC = t.brand(
  t.string,
  (x): x is t.Branded<string, ObsoleteIdentityIdBrand> =>
    typeof x !== 'string' ||
    x.match(
      RegExp('^[aepus]{2}-[\\w]{4}-\\d:[a-f\\d]{8}(-[a-f\\d]{4}){3}-[a-f\\d]{12}$'),
    ) !== null,
  'ObsoleteIdentityId',
);
export interface ObsoleteIdentityIdBrand {
  readonly ObsoleteIdentityId: unique symbol;
}
/** require('io-ts-validator').validator(nonEmptyArray(ObsoleteIdentityId)).decodeSync(examplesObsoleteIdentityId) // => examplesObsoleteIdentityId */
export const examplesObsoleteIdentityId: NonEmptyArray<ObsoleteIdentityId> = ([
  'eu-west-1:4828507e-683f-41bf-9d87-689808fbf958',
] as unknown) as NonEmptyArray<ObsoleteIdentityId>;

// IdentityId
// The purpose of this remains a mystery
export type IdentityId = t.Branded<ObsoleteIdentityId | Uuid, IdentityIdBrand>;
export type IdentityIdC = t.BrandC<
  t.UnionC<[typeof ObsoleteIdentityId, typeof Uuid]>,
  IdentityIdBrand
>;
export const IdentityId: IdentityIdC = t.brand(
  t.union([ObsoleteIdentityId, Uuid]),
  (x): x is t.Branded<ObsoleteIdentityId | Uuid, IdentityIdBrand> => true,
  'IdentityId',
);
export interface IdentityIdBrand {
  readonly IdentityId: unique symbol;
}
/** require('io-ts-validator').validator(nonEmptyArray(IdentityId)).decodeSync(examplesIdentityId) // => examplesIdentityId */
export const examplesIdentityId: NonEmptyArray<IdentityId> = ([
  'eu-west-1:4828507e-683f-41bf-9d87-689808fbf958',
  '4828507e-683f-41bf-9d87-689808fbf958',
] as unknown) as NonEmptyArray<IdentityId>;

// Currency
// Accepted monetary unit in ISO 4127 format, see https://en.wikipedia.org/wiki/ISO_4217#cite_note-1
export type Currency = t.Branded<
  string & ('EUR' | 'GBP' | 'SGD' | 'JPY' | 'CHF'),
  CurrencyBrand
>;
export type CurrencyC = t.BrandC<
  t.IntersectionC<
    [
      t.StringC,
      t.UnionC<
        [
          t.LiteralC<'EUR'>,
          t.LiteralC<'GBP'>,
          t.LiteralC<'SGD'>,
          t.LiteralC<'JPY'>,
          t.LiteralC<'CHF'>,
        ]
      >,
    ]
  >,
  CurrencyBrand
>;
export const Currency: CurrencyC = t.brand(
  t.intersection([
    t.string,
    t.union([
      t.literal('EUR'),
      t.literal('GBP'),
      t.literal('SGD'),
      t.literal('JPY'),
      t.literal('CHF'),
    ]),
  ]),
  (x): x is t.Branded<string & ('EUR' | 'GBP' | 'SGD' | 'JPY' | 'CHF'), CurrencyBrand> =>
    true,
  'Currency',
);
export interface CurrencyBrand {
  readonly Currency: unique symbol;
}

// CurrencyOrToken
// The purpose of this remains a mystery
export type CurrencyOrToken = t.Branded<Currency | 'TOKEN', CurrencyOrTokenBrand>;
export type CurrencyOrTokenC = t.BrandC<
  t.UnionC<[typeof Currency, t.LiteralC<'TOKEN'>]>,
  CurrencyOrTokenBrand
>;
export const CurrencyOrToken: CurrencyOrTokenC = t.brand(
  t.union([Currency, t.literal('TOKEN')]),
  (x): x is t.Branded<Currency | 'TOKEN', CurrencyOrTokenBrand> => true,
  'CurrencyOrToken',
);
export interface CurrencyOrTokenBrand {
  readonly CurrencyOrToken: unique symbol;
}

// CurrencyEUR
// The purpose of this remains a mystery
export type CurrencyEUR = t.Branded<Currency & 'EUR', CurrencyEURBrand>;
export type CurrencyEURC = t.BrandC<
  t.IntersectionC<[typeof Currency, t.LiteralC<'EUR'>]>,
  CurrencyEURBrand
>;
export const CurrencyEUR: CurrencyEURC = t.brand(
  t.intersection([Currency, t.literal('EUR')]),
  (x): x is t.Branded<Currency & 'EUR', CurrencyEURBrand> => true,
  'CurrencyEUR',
);
export interface CurrencyEURBrand {
  readonly CurrencyEUR: unique symbol;
}
/** require('io-ts-validator').validator(CurrencyEUR).decodeSync(defaultCurrencyEUR) // => defaultCurrencyEUR */
export const defaultCurrencyEUR: CurrencyEUR = ('EUR' as unknown) as CurrencyEUR;

// CurrencyGBP
// The purpose of this remains a mystery
export type CurrencyGBP = t.Branded<Currency & 'GBP', CurrencyGBPBrand>;
export type CurrencyGBPC = t.BrandC<
  t.IntersectionC<[typeof Currency, t.LiteralC<'GBP'>]>,
  CurrencyGBPBrand
>;
export const CurrencyGBP: CurrencyGBPC = t.brand(
  t.intersection([Currency, t.literal('GBP')]),
  (x): x is t.Branded<Currency & 'GBP', CurrencyGBPBrand> => true,
  'CurrencyGBP',
);
export interface CurrencyGBPBrand {
  readonly CurrencyGBP: unique symbol;
}
/** require('io-ts-validator').validator(CurrencyGBP).decodeSync(defaultCurrencyGBP) // => defaultCurrencyGBP */
export const defaultCurrencyGBP: CurrencyGBP = ('GBP' as unknown) as CurrencyGBP;

// CurrencySGD
// The purpose of this remains a mystery
export type CurrencySGD = t.Branded<Currency & 'SGD', CurrencySGDBrand>;
export type CurrencySGDC = t.BrandC<
  t.IntersectionC<[typeof Currency, t.LiteralC<'SGD'>]>,
  CurrencySGDBrand
>;
export const CurrencySGD: CurrencySGDC = t.brand(
  t.intersection([Currency, t.literal('SGD')]),
  (x): x is t.Branded<Currency & 'SGD', CurrencySGDBrand> => true,
  'CurrencySGD',
);
export interface CurrencySGDBrand {
  readonly CurrencySGD: unique symbol;
}
/** require('io-ts-validator').validator(CurrencySGD).decodeSync(defaultCurrencySGD) // => defaultCurrencySGD */
export const defaultCurrencySGD: CurrencySGD = ('SGD' as unknown) as CurrencySGD;

// CurrencyJPY
// The purpose of this remains a mystery
export type CurrencyJPY = t.Branded<Currency & 'JPY', CurrencyJPYBrand>;
export type CurrencyJPYC = t.BrandC<
  t.IntersectionC<[typeof Currency, t.LiteralC<'JPY'>]>,
  CurrencyJPYBrand
>;
export const CurrencyJPY: CurrencyJPYC = t.brand(
  t.intersection([Currency, t.literal('JPY')]),
  (x): x is t.Branded<Currency & 'JPY', CurrencyJPYBrand> => true,
  'CurrencyJPY',
);
export interface CurrencyJPYBrand {
  readonly CurrencyJPY: unique symbol;
}
/** require('io-ts-validator').validator(CurrencyJPY).decodeSync(defaultCurrencyJPY) // => defaultCurrencyJPY */
export const defaultCurrencyJPY: CurrencyJPY = ('JPY' as unknown) as CurrencyJPY;

// CurrencyCHF
// The purpose of this remains a mystery
export type CurrencyCHF = t.Branded<Currency & 'CHF', CurrencyCHFBrand>;
export type CurrencyCHFC = t.BrandC<
  t.IntersectionC<[typeof Currency, t.LiteralC<'CHF'>]>,
  CurrencyCHFBrand
>;
export const CurrencyCHF: CurrencyCHFC = t.brand(
  t.intersection([Currency, t.literal('CHF')]),
  (x): x is t.Branded<Currency & 'CHF', CurrencyCHFBrand> => true,
  'CurrencyCHF',
);
export interface CurrencyCHFBrand {
  readonly CurrencyCHF: unique symbol;
}
/** require('io-ts-validator').validator(CurrencyCHF).decodeSync(defaultCurrencyCHF) // => defaultCurrencyCHF */
export const defaultCurrencyCHF: CurrencyCHF = ('CHF' as unknown) as CurrencyCHF;

// Time
// POSIX time in milliseconds, https://en.wikipedia.org/wiki/Unix_time
export type Time = t.Branded<number, TimeBrand>;
export type TimeC = t.BrandC<t.NumberC, TimeBrand>;
export const Time: TimeC = t.brand(
  t.number,
  (x): x is t.Branded<number, TimeBrand> =>
    (typeof x !== 'number' || x >= 126230400000) &&
    (typeof x !== 'number' || x <= 9007199254740991) &&
    Number.isInteger(x),
  'Time',
);
export interface TimeBrand {
  readonly Time: unique symbol;
}
/** require('io-ts-validator').validator(Time).decodeSync(minimumTime) // => minimumTime */
export const minimumTime: Time = (126230400000 as unknown) as Time;
/** require('io-ts-validator').validator(Time).decodeSync(maximumTime) // => maximumTime */
export const maximumTime: Time = (9007199254740991 as unknown) as Time;

// Duration
// duration in milliseconds (negative values permitted), https://en.wikipedia.org/wiki/Unix_time
export type Duration = t.Branded<number, DurationBrand>;
export type DurationC = t.BrandC<t.NumberC, DurationBrand>;
export const Duration: DurationC = t.brand(
  t.number,
  (x): x is t.Branded<number, DurationBrand> =>
    (typeof x !== 'number' || x >= -9007199254740991) &&
    (typeof x !== 'number' || x <= 9007199254740991) &&
    Number.isInteger(x),
  'Duration',
);
export interface DurationBrand {
  readonly Duration: unique symbol;
}
/** require('io-ts-validator').validator(Duration).decodeSync(minimumDuration) // => minimumDuration */
export const minimumDuration: Duration = (-9007199254740991 as unknown) as Duration;
/** require('io-ts-validator').validator(Duration).decodeSync(maximumDuration) // => maximumDuration */
export const maximumDuration: Duration = (9007199254740991 as unknown) as Duration;

// IsoDate
// A date in the form YYYY-MM-DD without a time component
export type IsoDate = t.Branded<string, IsoDateBrand>;
export type IsoDateC = t.BrandC<t.StringC, IsoDateBrand>;
export const IsoDate: IsoDateC = t.brand(
  t.string,
  (x): x is t.Branded<string, IsoDateBrand> =>
    typeof x !== 'string' || x.match(RegExp('^\\d{4}-\\d{2}-\\d{2}')) !== null,
  'IsoDate',
);
export interface IsoDateBrand {
  readonly IsoDate: unique symbol;
}

// Units
// The default export. More information at the top.
export type Units = t.Branded<unknown, UnitsBrand>;
export type UnitsC = t.BrandC<t.UnknownC, UnitsBrand>;
export const Units: UnitsC = t.brand(
  t.unknown,
  (x): x is t.Branded<unknown, UnitsBrand> => true,
  'Units',
);
export interface UnitsBrand {
  readonly Units: unique symbol;
}

export default Units;

// Success
