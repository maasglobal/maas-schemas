/*

undefined
A fare/price as billed to the user in WMPs or in tokens

!!! AUTO GENERATED BY IOTSFJS REFRAIN FROM MANUAL EDITING !!!
See https://www.npmjs.com/package/io-ts-from-json-schema

*/

import { NonEmptyArray } from 'fp-ts/lib/NonEmptyArray';
import * as t from 'io-ts';
import { nonEmptyArray } from 'io-ts-types/lib/nonEmptyArray';

import * as Common_ from './common';
import * as Units_ from './units';

export type NullBrand = {
  readonly Null: unique symbol;
};
export type NullC = t.BrandC<t.UnknownC, NullBrand>;
export const Null: NullC = t.brand(
  t.unknown,
  (n): n is t.Branded<unknown, NullBrand> => n === null,
  'Null',
);
export type Null = t.TypeOf<typeof Null>;

export type Defined = {} | null;
export class DefinedType extends t.Type<Defined> {
  readonly _tag: 'DefinedType' = 'DefinedType';
  constructor() {
    super(
      'defined',
      (u): u is Defined => typeof u !== 'undefined',
      (u, c) => (this.is(u) ? t.success(u) : t.failure(u, c)),
      t.identity,
    );
  }
}
export type DefinedC = {} & DefinedType;
export const Defined: DefinedC = new DefinedType();

export const schemaId = 'https://schemas.maas.global/core/components/fare.json';

// TokenId
// The purpose of this remains a mystery
export type TokenId = t.Branded<string, TokenIdBrand>;
export type TokenIdC = t.BrandC<t.StringC, TokenIdBrand>;
export const TokenId: TokenIdC = t.brand(
  t.string,
  (x): x is t.Branded<string, TokenIdBrand> =>
    typeof x !== 'string' || x.match(RegExp('^[a-z]+(-[a-z0-9_]+)+$', 'u')) !== null,
  'TokenId',
);
export type TokenIdBrand = {
  readonly TokenId: unique symbol;
};

// FareType
// The purpose of this remains a mystery
export type FareType = t.Branded<string & ('charge' | 'refund'), FareTypeBrand>;
export type FareTypeC = t.BrandC<
  t.IntersectionC<[t.StringC, t.UnionC<[t.LiteralC<'charge'>, t.LiteralC<'refund'>]>]>,
  FareTypeBrand
>;
export const FareType: FareTypeC = t.brand(
  t.intersection([t.string, t.union([t.literal('charge'), t.literal('refund')])]),
  (x): x is t.Branded<string & ('charge' | 'refund'), FareTypeBrand> => true,
  'FareType',
);
export type FareTypeBrand = {
  readonly FareType: unique symbol;
};

// FareTypeCHARGE
// The purpose of this remains a mystery
export type FareTypeCHARGE = t.Branded<FareType & 'charge', FareTypeCHARGEBrand>;
export type FareTypeCHARGEC = t.BrandC<
  t.IntersectionC<[typeof FareType, t.LiteralC<'charge'>]>,
  FareTypeCHARGEBrand
>;
export const FareTypeCHARGE: FareTypeCHARGEC = t.brand(
  t.intersection([FareType, t.literal('charge')]),
  (x): x is t.Branded<FareType & 'charge', FareTypeCHARGEBrand> => true,
  'FareTypeCHARGE',
);
export type FareTypeCHARGEBrand = {
  readonly FareTypeCHARGE: unique symbol;
};
/** require('io-ts-validator').validator(FareTypeCHARGE).decodeSync(defaultFareTypeCHARGE) // => defaultFareTypeCHARGE */
export const defaultFareTypeCHARGE: FareTypeCHARGE =
  'charge' as unknown as FareTypeCHARGE;

// FareTypeREFUND
// The purpose of this remains a mystery
export type FareTypeREFUND = t.Branded<FareType & 'refund', FareTypeREFUNDBrand>;
export type FareTypeREFUNDC = t.BrandC<
  t.IntersectionC<[typeof FareType, t.LiteralC<'refund'>]>,
  FareTypeREFUNDBrand
>;
export const FareTypeREFUND: FareTypeREFUNDC = t.brand(
  t.intersection([FareType, t.literal('refund')]),
  (x): x is t.Branded<FareType & 'refund', FareTypeREFUNDBrand> => true,
  'FareTypeREFUND',
);
export type FareTypeREFUNDBrand = {
  readonly FareTypeREFUND: unique symbol;
};
/** require('io-ts-validator').validator(FareTypeREFUND).decodeSync(defaultFareTypeREFUND) // => defaultFareTypeREFUND */
export const defaultFareTypeREFUND: FareTypeREFUND =
  'refund' as unknown as FareTypeREFUND;

// Fare
// The default export. More information at the top.
export type Fare = t.Branded<
  {
    amount?: number | Null;
    currency?: Units_.Currency | Common_.MetaCurrency | TokenId;
    tokenId?: TokenId;
    hidden?: boolean;
    originalAmount?: number | Null;
    productionAmount?: number | Null;
    type?: FareType;
  } & {
    amount: Defined;
    currency: Defined;
  },
  FareBrand
>;
export type FareC = t.BrandC<
  t.IntersectionC<
    [
      t.PartialC<{
        amount: t.UnionC<[t.NumberC, typeof Null]>;
        currency: t.UnionC<
          [typeof Units_.Currency, typeof Common_.MetaCurrency, typeof TokenId]
        >;
        tokenId: typeof TokenId;
        hidden: t.BooleanC;
        originalAmount: t.UnionC<[t.NumberC, typeof Null]>;
        productionAmount: t.UnionC<[t.NumberC, typeof Null]>;
        type: typeof FareType;
      }>,
      t.TypeC<{
        amount: typeof Defined;
        currency: typeof Defined;
      }>,
    ]
  >,
  FareBrand
>;
export const Fare: FareC = t.brand(
  t.intersection([
    t.partial({
      amount: t.union([t.number, Null]),
      currency: t.union([Units_.Currency, Common_.MetaCurrency, TokenId]),
      tokenId: TokenId,
      hidden: t.boolean,
      originalAmount: t.union([t.number, Null]),
      productionAmount: t.union([t.number, Null]),
      type: FareType,
    }),
    t.type({
      amount: Defined,
      currency: Defined,
    }),
  ]),
  (
    x,
  ): x is t.Branded<
    {
      amount?: number | Null;
      currency?: Units_.Currency | Common_.MetaCurrency | TokenId;
      tokenId?: TokenId;
      hidden?: boolean;
      originalAmount?: number | Null;
      productionAmount?: number | Null;
      type?: FareType;
    } & {
      amount: Defined;
      currency: Defined;
    },
    FareBrand
  > => true,
  'Fare',
);
export type FareBrand = {
  readonly Fare: unique symbol;
};
/** require('io-ts-validator').validator(nonEmptyArray(Fare)).decodeSync(examplesFare) // => examplesFare */
export const examplesFare: NonEmptyArray<Fare> = [
  { type: 'charge', amount: 1200, currency: 'EUR', productionAmount: 1234 },
  { type: 'refund', amount: 1200, currency: 'EUR', productionAmount: 1234 },
  { type: 'charge', amount: 1200, currency: 'WMP', productionAmount: 1234 },
  { type: 'refund', amount: 1200, currency: 'WMP', productionAmount: 1234 },
  { type: 'charge', amount: 12, currency: 'TOKEN', tokenId: 'fi-package-benefit' },
  { type: 'refund', amount: 12, currency: 'TOKEN', tokenId: 'fi-package-benefit' },
  {
    type: 'charge',
    amount: 12,
    currency: 'fi-package-benefit',
    tokenId: 'fi-package-benefit',
  },
  {
    type: 'refund',
    amount: 12,
    currency: 'fi-package-benefit',
    tokenId: 'fi-package-benefit',
  },
] as unknown as NonEmptyArray<Fare>;

export default Fare;

// Success
