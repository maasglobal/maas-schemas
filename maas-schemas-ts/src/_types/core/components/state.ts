/*

undefined
MaaS state schemas

!!! AUTO GENERATED BY IOTSFJS REFRAIN FROM MANUAL EDITING !!!
See https://www.npmjs.com/package/io-ts-from-json-schema

*/

import * as t from 'io-ts';

export const schemaId = 'https://schemas.maas.global/core/components/state.json';

// BookingState
// The life-cycle state of a booking
export type BookingState = t.Branded<
  string &
    (
      | 'START'
      | 'PENDING'
      | 'PAID'
      | 'PENDING_RESERVATION'
      | 'RESERVED'
      | 'CONFIRMED'
      | 'ARRIVED'
      | 'ACTIVATED'
      | 'ON_HOLD'
      | 'CANCELLED'
      | 'EXPIRED'
      | 'REJECTED'
      | 'FINISHED'
      | 'UNKNOWN'
    ),
  BookingStateBrand
>;
export type BookingStateC = t.BrandC<
  t.IntersectionC<
    [
      t.StringC,
      t.UnionC<
        [
          t.LiteralC<'START'>,
          t.LiteralC<'PENDING'>,
          t.LiteralC<'PAID'>,
          t.LiteralC<'PENDING_RESERVATION'>,
          t.LiteralC<'RESERVED'>,
          t.LiteralC<'CONFIRMED'>,
          t.LiteralC<'ARRIVED'>,
          t.LiteralC<'ACTIVATED'>,
          t.LiteralC<'ON_HOLD'>,
          t.LiteralC<'CANCELLED'>,
          t.LiteralC<'EXPIRED'>,
          t.LiteralC<'REJECTED'>,
          t.LiteralC<'FINISHED'>,
          t.LiteralC<'UNKNOWN'>,
        ]
      >,
    ]
  >,
  BookingStateBrand
>;
export const BookingState: BookingStateC = t.brand(
  t.intersection([
    t.string,
    t.union([
      t.literal('START'),
      t.literal('PENDING'),
      t.literal('PAID'),
      t.literal('PENDING_RESERVATION'),
      t.literal('RESERVED'),
      t.literal('CONFIRMED'),
      t.literal('ARRIVED'),
      t.literal('ACTIVATED'),
      t.literal('ON_HOLD'),
      t.literal('CANCELLED'),
      t.literal('EXPIRED'),
      t.literal('REJECTED'),
      t.literal('FINISHED'),
      t.literal('UNKNOWN'),
    ]),
  ]),
  (
    x,
  ): x is t.Branded<
    string &
      (
        | 'START'
        | 'PENDING'
        | 'PAID'
        | 'PENDING_RESERVATION'
        | 'RESERVED'
        | 'CONFIRMED'
        | 'ARRIVED'
        | 'ACTIVATED'
        | 'ON_HOLD'
        | 'CANCELLED'
        | 'EXPIRED'
        | 'REJECTED'
        | 'FINISHED'
        | 'UNKNOWN'
      ),
    BookingStateBrand
  > => true,
  'BookingState',
);
export interface BookingStateBrand {
  readonly BookingState: unique symbol;
}

// BookingStateSTART
// The purpose of this remains a mystery
export type BookingStateSTART = t.Branded<BookingState & 'START', BookingStateSTARTBrand>;
export type BookingStateSTARTC = t.BrandC<
  t.IntersectionC<[typeof BookingState, t.LiteralC<'START'>]>,
  BookingStateSTARTBrand
>;
export const BookingStateSTART: BookingStateSTARTC = t.brand(
  t.intersection([BookingState, t.literal('START')]),
  (x): x is t.Branded<BookingState & 'START', BookingStateSTARTBrand> => true,
  'BookingStateSTART',
);
export interface BookingStateSTARTBrand {
  readonly BookingStateSTART: unique symbol;
}
/** require('io-ts-validator').validator(BookingStateSTART).decodeSync(defaultBookingStateSTART) // => defaultBookingStateSTART */
export const defaultBookingStateSTART: BookingStateSTART = ('START' as unknown) as BookingStateSTART;

// BookingStatePENDING
// The purpose of this remains a mystery
export type BookingStatePENDING = t.Branded<
  BookingState & 'PENDING',
  BookingStatePENDINGBrand
>;
export type BookingStatePENDINGC = t.BrandC<
  t.IntersectionC<[typeof BookingState, t.LiteralC<'PENDING'>]>,
  BookingStatePENDINGBrand
>;
export const BookingStatePENDING: BookingStatePENDINGC = t.brand(
  t.intersection([BookingState, t.literal('PENDING')]),
  (x): x is t.Branded<BookingState & 'PENDING', BookingStatePENDINGBrand> => true,
  'BookingStatePENDING',
);
export interface BookingStatePENDINGBrand {
  readonly BookingStatePENDING: unique symbol;
}
/** require('io-ts-validator').validator(BookingStatePENDING).decodeSync(defaultBookingStatePENDING) // => defaultBookingStatePENDING */
export const defaultBookingStatePENDING: BookingStatePENDING = ('PENDING' as unknown) as BookingStatePENDING;

// BookingStatePAID
// The purpose of this remains a mystery
export type BookingStatePAID = t.Branded<BookingState & 'PAID', BookingStatePAIDBrand>;
export type BookingStatePAIDC = t.BrandC<
  t.IntersectionC<[typeof BookingState, t.LiteralC<'PAID'>]>,
  BookingStatePAIDBrand
>;
export const BookingStatePAID: BookingStatePAIDC = t.brand(
  t.intersection([BookingState, t.literal('PAID')]),
  (x): x is t.Branded<BookingState & 'PAID', BookingStatePAIDBrand> => true,
  'BookingStatePAID',
);
export interface BookingStatePAIDBrand {
  readonly BookingStatePAID: unique symbol;
}
/** require('io-ts-validator').validator(BookingStatePAID).decodeSync(defaultBookingStatePAID) // => defaultBookingStatePAID */
export const defaultBookingStatePAID: BookingStatePAID = ('PAID' as unknown) as BookingStatePAID;

// BookingStatePENDING_RESERVATION
// The purpose of this remains a mystery
export type BookingStatePENDING_RESERVATION = t.Branded<
  BookingState & 'PENDING_RESERVATION',
  BookingStatePENDING_RESERVATIONBrand
>;
export type BookingStatePENDING_RESERVATIONC = t.BrandC<
  t.IntersectionC<[typeof BookingState, t.LiteralC<'PENDING_RESERVATION'>]>,
  BookingStatePENDING_RESERVATIONBrand
>;
export const BookingStatePENDING_RESERVATION: BookingStatePENDING_RESERVATIONC = t.brand(
  t.intersection([BookingState, t.literal('PENDING_RESERVATION')]),
  (
    x,
  ): x is t.Branded<
    BookingState & 'PENDING_RESERVATION',
    BookingStatePENDING_RESERVATIONBrand
  > => true,
  'BookingStatePENDING_RESERVATION',
);
export interface BookingStatePENDING_RESERVATIONBrand {
  readonly BookingStatePENDING_RESERVATION: unique symbol;
}
/** require('io-ts-validator').validator(BookingStatePENDING_RESERVATION).decodeSync(defaultBookingStatePENDING_RESERVATION) // => defaultBookingStatePENDING_RESERVATION */
export const defaultBookingStatePENDING_RESERVATION: BookingStatePENDING_RESERVATION = ('PENDING_RESERVATION' as unknown) as BookingStatePENDING_RESERVATION;

// BookingStateRESERVED
// The purpose of this remains a mystery
export type BookingStateRESERVED = t.Branded<
  BookingState & 'RESERVED',
  BookingStateRESERVEDBrand
>;
export type BookingStateRESERVEDC = t.BrandC<
  t.IntersectionC<[typeof BookingState, t.LiteralC<'RESERVED'>]>,
  BookingStateRESERVEDBrand
>;
export const BookingStateRESERVED: BookingStateRESERVEDC = t.brand(
  t.intersection([BookingState, t.literal('RESERVED')]),
  (x): x is t.Branded<BookingState & 'RESERVED', BookingStateRESERVEDBrand> => true,
  'BookingStateRESERVED',
);
export interface BookingStateRESERVEDBrand {
  readonly BookingStateRESERVED: unique symbol;
}
/** require('io-ts-validator').validator(BookingStateRESERVED).decodeSync(defaultBookingStateRESERVED) // => defaultBookingStateRESERVED */
export const defaultBookingStateRESERVED: BookingStateRESERVED = ('RESERVED' as unknown) as BookingStateRESERVED;

// BookingStateCONFIRMED
// The purpose of this remains a mystery
export type BookingStateCONFIRMED = t.Branded<
  BookingState & 'CONFIRMED',
  BookingStateCONFIRMEDBrand
>;
export type BookingStateCONFIRMEDC = t.BrandC<
  t.IntersectionC<[typeof BookingState, t.LiteralC<'CONFIRMED'>]>,
  BookingStateCONFIRMEDBrand
>;
export const BookingStateCONFIRMED: BookingStateCONFIRMEDC = t.brand(
  t.intersection([BookingState, t.literal('CONFIRMED')]),
  (x): x is t.Branded<BookingState & 'CONFIRMED', BookingStateCONFIRMEDBrand> => true,
  'BookingStateCONFIRMED',
);
export interface BookingStateCONFIRMEDBrand {
  readonly BookingStateCONFIRMED: unique symbol;
}
/** require('io-ts-validator').validator(BookingStateCONFIRMED).decodeSync(defaultBookingStateCONFIRMED) // => defaultBookingStateCONFIRMED */
export const defaultBookingStateCONFIRMED: BookingStateCONFIRMED = ('CONFIRMED' as unknown) as BookingStateCONFIRMED;

// BookingStateARRIVED
// The purpose of this remains a mystery
export type BookingStateARRIVED = t.Branded<
  BookingState & 'ARRIVED',
  BookingStateARRIVEDBrand
>;
export type BookingStateARRIVEDC = t.BrandC<
  t.IntersectionC<[typeof BookingState, t.LiteralC<'ARRIVED'>]>,
  BookingStateARRIVEDBrand
>;
export const BookingStateARRIVED: BookingStateARRIVEDC = t.brand(
  t.intersection([BookingState, t.literal('ARRIVED')]),
  (x): x is t.Branded<BookingState & 'ARRIVED', BookingStateARRIVEDBrand> => true,
  'BookingStateARRIVED',
);
export interface BookingStateARRIVEDBrand {
  readonly BookingStateARRIVED: unique symbol;
}
/** require('io-ts-validator').validator(BookingStateARRIVED).decodeSync(defaultBookingStateARRIVED) // => defaultBookingStateARRIVED */
export const defaultBookingStateARRIVED: BookingStateARRIVED = ('ARRIVED' as unknown) as BookingStateARRIVED;

// BookingStateACTIVATED
// The purpose of this remains a mystery
export type BookingStateACTIVATED = t.Branded<
  BookingState & 'ACTIVATED',
  BookingStateACTIVATEDBrand
>;
export type BookingStateACTIVATEDC = t.BrandC<
  t.IntersectionC<[typeof BookingState, t.LiteralC<'ACTIVATED'>]>,
  BookingStateACTIVATEDBrand
>;
export const BookingStateACTIVATED: BookingStateACTIVATEDC = t.brand(
  t.intersection([BookingState, t.literal('ACTIVATED')]),
  (x): x is t.Branded<BookingState & 'ACTIVATED', BookingStateACTIVATEDBrand> => true,
  'BookingStateACTIVATED',
);
export interface BookingStateACTIVATEDBrand {
  readonly BookingStateACTIVATED: unique symbol;
}
/** require('io-ts-validator').validator(BookingStateACTIVATED).decodeSync(defaultBookingStateACTIVATED) // => defaultBookingStateACTIVATED */
export const defaultBookingStateACTIVATED: BookingStateACTIVATED = ('ACTIVATED' as unknown) as BookingStateACTIVATED;

// BookingStateON_HOLD
// The purpose of this remains a mystery
export type BookingStateON_HOLD = t.Branded<
  BookingState & 'ON_HOLD',
  BookingStateON_HOLDBrand
>;
export type BookingStateON_HOLDC = t.BrandC<
  t.IntersectionC<[typeof BookingState, t.LiteralC<'ON_HOLD'>]>,
  BookingStateON_HOLDBrand
>;
export const BookingStateON_HOLD: BookingStateON_HOLDC = t.brand(
  t.intersection([BookingState, t.literal('ON_HOLD')]),
  (x): x is t.Branded<BookingState & 'ON_HOLD', BookingStateON_HOLDBrand> => true,
  'BookingStateON_HOLD',
);
export interface BookingStateON_HOLDBrand {
  readonly BookingStateON_HOLD: unique symbol;
}
/** require('io-ts-validator').validator(BookingStateON_HOLD).decodeSync(defaultBookingStateON_HOLD) // => defaultBookingStateON_HOLD */
export const defaultBookingStateON_HOLD: BookingStateON_HOLD = ('ON_HOLD' as unknown) as BookingStateON_HOLD;

// BookingStateCANCELLED
// The purpose of this remains a mystery
export type BookingStateCANCELLED = t.Branded<
  BookingState & 'CANCELLED',
  BookingStateCANCELLEDBrand
>;
export type BookingStateCANCELLEDC = t.BrandC<
  t.IntersectionC<[typeof BookingState, t.LiteralC<'CANCELLED'>]>,
  BookingStateCANCELLEDBrand
>;
export const BookingStateCANCELLED: BookingStateCANCELLEDC = t.brand(
  t.intersection([BookingState, t.literal('CANCELLED')]),
  (x): x is t.Branded<BookingState & 'CANCELLED', BookingStateCANCELLEDBrand> => true,
  'BookingStateCANCELLED',
);
export interface BookingStateCANCELLEDBrand {
  readonly BookingStateCANCELLED: unique symbol;
}
/** require('io-ts-validator').validator(BookingStateCANCELLED).decodeSync(defaultBookingStateCANCELLED) // => defaultBookingStateCANCELLED */
export const defaultBookingStateCANCELLED: BookingStateCANCELLED = ('CANCELLED' as unknown) as BookingStateCANCELLED;

// BookingStateEXPIRED
// The purpose of this remains a mystery
export type BookingStateEXPIRED = t.Branded<
  BookingState & 'EXPIRED',
  BookingStateEXPIREDBrand
>;
export type BookingStateEXPIREDC = t.BrandC<
  t.IntersectionC<[typeof BookingState, t.LiteralC<'EXPIRED'>]>,
  BookingStateEXPIREDBrand
>;
export const BookingStateEXPIRED: BookingStateEXPIREDC = t.brand(
  t.intersection([BookingState, t.literal('EXPIRED')]),
  (x): x is t.Branded<BookingState & 'EXPIRED', BookingStateEXPIREDBrand> => true,
  'BookingStateEXPIRED',
);
export interface BookingStateEXPIREDBrand {
  readonly BookingStateEXPIRED: unique symbol;
}
/** require('io-ts-validator').validator(BookingStateEXPIRED).decodeSync(defaultBookingStateEXPIRED) // => defaultBookingStateEXPIRED */
export const defaultBookingStateEXPIRED: BookingStateEXPIRED = ('EXPIRED' as unknown) as BookingStateEXPIRED;

// BookingStateREJECTED
// The purpose of this remains a mystery
export type BookingStateREJECTED = t.Branded<
  BookingState & 'REJECTED',
  BookingStateREJECTEDBrand
>;
export type BookingStateREJECTEDC = t.BrandC<
  t.IntersectionC<[typeof BookingState, t.LiteralC<'REJECTED'>]>,
  BookingStateREJECTEDBrand
>;
export const BookingStateREJECTED: BookingStateREJECTEDC = t.brand(
  t.intersection([BookingState, t.literal('REJECTED')]),
  (x): x is t.Branded<BookingState & 'REJECTED', BookingStateREJECTEDBrand> => true,
  'BookingStateREJECTED',
);
export interface BookingStateREJECTEDBrand {
  readonly BookingStateREJECTED: unique symbol;
}
/** require('io-ts-validator').validator(BookingStateREJECTED).decodeSync(defaultBookingStateREJECTED) // => defaultBookingStateREJECTED */
export const defaultBookingStateREJECTED: BookingStateREJECTED = ('REJECTED' as unknown) as BookingStateREJECTED;

// BookingStateFINISHED
// The purpose of this remains a mystery
export type BookingStateFINISHED = t.Branded<
  BookingState & 'FINISHED',
  BookingStateFINISHEDBrand
>;
export type BookingStateFINISHEDC = t.BrandC<
  t.IntersectionC<[typeof BookingState, t.LiteralC<'FINISHED'>]>,
  BookingStateFINISHEDBrand
>;
export const BookingStateFINISHED: BookingStateFINISHEDC = t.brand(
  t.intersection([BookingState, t.literal('FINISHED')]),
  (x): x is t.Branded<BookingState & 'FINISHED', BookingStateFINISHEDBrand> => true,
  'BookingStateFINISHED',
);
export interface BookingStateFINISHEDBrand {
  readonly BookingStateFINISHED: unique symbol;
}
/** require('io-ts-validator').validator(BookingStateFINISHED).decodeSync(defaultBookingStateFINISHED) // => defaultBookingStateFINISHED */
export const defaultBookingStateFINISHED: BookingStateFINISHED = ('FINISHED' as unknown) as BookingStateFINISHED;

// BookingStateUNKNOWN
// The purpose of this remains a mystery
export type BookingStateUNKNOWN = t.Branded<
  BookingState & 'UNKNOWN',
  BookingStateUNKNOWNBrand
>;
export type BookingStateUNKNOWNC = t.BrandC<
  t.IntersectionC<[typeof BookingState, t.LiteralC<'UNKNOWN'>]>,
  BookingStateUNKNOWNBrand
>;
export const BookingStateUNKNOWN: BookingStateUNKNOWNC = t.brand(
  t.intersection([BookingState, t.literal('UNKNOWN')]),
  (x): x is t.Branded<BookingState & 'UNKNOWN', BookingStateUNKNOWNBrand> => true,
  'BookingStateUNKNOWN',
);
export interface BookingStateUNKNOWNBrand {
  readonly BookingStateUNKNOWN: unique symbol;
}
/** require('io-ts-validator').validator(BookingStateUNKNOWN).decodeSync(defaultBookingStateUNKNOWN) // => defaultBookingStateUNKNOWN */
export const defaultBookingStateUNKNOWN: BookingStateUNKNOWN = ('UNKNOWN' as unknown) as BookingStateUNKNOWN;

// LegState
// The life-cycle state of a leg
export type LegState = t.Branded<
  string &
    (
      | 'START'
      | 'PLANNED'
      | 'PAID'
      | 'ACTIVATED'
      | 'CANCELLED'
      | 'CANCELLED_WITH_ERRORS'
      | 'FINISHED'
    ),
  LegStateBrand
>;
export type LegStateC = t.BrandC<
  t.IntersectionC<
    [
      t.StringC,
      t.UnionC<
        [
          t.LiteralC<'START'>,
          t.LiteralC<'PLANNED'>,
          t.LiteralC<'PAID'>,
          t.LiteralC<'ACTIVATED'>,
          t.LiteralC<'CANCELLED'>,
          t.LiteralC<'CANCELLED_WITH_ERRORS'>,
          t.LiteralC<'FINISHED'>,
        ]
      >,
    ]
  >,
  LegStateBrand
>;
export const LegState: LegStateC = t.brand(
  t.intersection([
    t.string,
    t.union([
      t.literal('START'),
      t.literal('PLANNED'),
      t.literal('PAID'),
      t.literal('ACTIVATED'),
      t.literal('CANCELLED'),
      t.literal('CANCELLED_WITH_ERRORS'),
      t.literal('FINISHED'),
    ]),
  ]),
  (
    x,
  ): x is t.Branded<
    string &
      (
        | 'START'
        | 'PLANNED'
        | 'PAID'
        | 'ACTIVATED'
        | 'CANCELLED'
        | 'CANCELLED_WITH_ERRORS'
        | 'FINISHED'
      ),
    LegStateBrand
  > => true,
  'LegState',
);
export interface LegStateBrand {
  readonly LegState: unique symbol;
}

// LegStateSTART
// The purpose of this remains a mystery
export type LegStateSTART = t.Branded<LegState & 'START', LegStateSTARTBrand>;
export type LegStateSTARTC = t.BrandC<
  t.IntersectionC<[typeof LegState, t.LiteralC<'START'>]>,
  LegStateSTARTBrand
>;
export const LegStateSTART: LegStateSTARTC = t.brand(
  t.intersection([LegState, t.literal('START')]),
  (x): x is t.Branded<LegState & 'START', LegStateSTARTBrand> => true,
  'LegStateSTART',
);
export interface LegStateSTARTBrand {
  readonly LegStateSTART: unique symbol;
}
/** require('io-ts-validator').validator(LegStateSTART).decodeSync(defaultLegStateSTART) // => defaultLegStateSTART */
export const defaultLegStateSTART: LegStateSTART = ('START' as unknown) as LegStateSTART;

// LegStatePLANNED
// The purpose of this remains a mystery
export type LegStatePLANNED = t.Branded<LegState & 'PLANNED', LegStatePLANNEDBrand>;
export type LegStatePLANNEDC = t.BrandC<
  t.IntersectionC<[typeof LegState, t.LiteralC<'PLANNED'>]>,
  LegStatePLANNEDBrand
>;
export const LegStatePLANNED: LegStatePLANNEDC = t.brand(
  t.intersection([LegState, t.literal('PLANNED')]),
  (x): x is t.Branded<LegState & 'PLANNED', LegStatePLANNEDBrand> => true,
  'LegStatePLANNED',
);
export interface LegStatePLANNEDBrand {
  readonly LegStatePLANNED: unique symbol;
}
/** require('io-ts-validator').validator(LegStatePLANNED).decodeSync(defaultLegStatePLANNED) // => defaultLegStatePLANNED */
export const defaultLegStatePLANNED: LegStatePLANNED = ('PLANNED' as unknown) as LegStatePLANNED;

// LegStatePAID
// The purpose of this remains a mystery
export type LegStatePAID = t.Branded<LegState & 'PAID', LegStatePAIDBrand>;
export type LegStatePAIDC = t.BrandC<
  t.IntersectionC<[typeof LegState, t.LiteralC<'PAID'>]>,
  LegStatePAIDBrand
>;
export const LegStatePAID: LegStatePAIDC = t.brand(
  t.intersection([LegState, t.literal('PAID')]),
  (x): x is t.Branded<LegState & 'PAID', LegStatePAIDBrand> => true,
  'LegStatePAID',
);
export interface LegStatePAIDBrand {
  readonly LegStatePAID: unique symbol;
}
/** require('io-ts-validator').validator(LegStatePAID).decodeSync(defaultLegStatePAID) // => defaultLegStatePAID */
export const defaultLegStatePAID: LegStatePAID = ('PAID' as unknown) as LegStatePAID;

// LegStateACTIVATED
// The purpose of this remains a mystery
export type LegStateACTIVATED = t.Branded<LegState & 'ACTIVATED', LegStateACTIVATEDBrand>;
export type LegStateACTIVATEDC = t.BrandC<
  t.IntersectionC<[typeof LegState, t.LiteralC<'ACTIVATED'>]>,
  LegStateACTIVATEDBrand
>;
export const LegStateACTIVATED: LegStateACTIVATEDC = t.brand(
  t.intersection([LegState, t.literal('ACTIVATED')]),
  (x): x is t.Branded<LegState & 'ACTIVATED', LegStateACTIVATEDBrand> => true,
  'LegStateACTIVATED',
);
export interface LegStateACTIVATEDBrand {
  readonly LegStateACTIVATED: unique symbol;
}
/** require('io-ts-validator').validator(LegStateACTIVATED).decodeSync(defaultLegStateACTIVATED) // => defaultLegStateACTIVATED */
export const defaultLegStateACTIVATED: LegStateACTIVATED = ('ACTIVATED' as unknown) as LegStateACTIVATED;

// LegStateCANCELLED
// The purpose of this remains a mystery
export type LegStateCANCELLED = t.Branded<LegState & 'CANCELLED', LegStateCANCELLEDBrand>;
export type LegStateCANCELLEDC = t.BrandC<
  t.IntersectionC<[typeof LegState, t.LiteralC<'CANCELLED'>]>,
  LegStateCANCELLEDBrand
>;
export const LegStateCANCELLED: LegStateCANCELLEDC = t.brand(
  t.intersection([LegState, t.literal('CANCELLED')]),
  (x): x is t.Branded<LegState & 'CANCELLED', LegStateCANCELLEDBrand> => true,
  'LegStateCANCELLED',
);
export interface LegStateCANCELLEDBrand {
  readonly LegStateCANCELLED: unique symbol;
}
/** require('io-ts-validator').validator(LegStateCANCELLED).decodeSync(defaultLegStateCANCELLED) // => defaultLegStateCANCELLED */
export const defaultLegStateCANCELLED: LegStateCANCELLED = ('CANCELLED' as unknown) as LegStateCANCELLED;

// LegStateCANCELLED_WITH_ERRORS
// The purpose of this remains a mystery
export type LegStateCANCELLED_WITH_ERRORS = t.Branded<
  LegState & 'CANCELLED_WITH_ERRORS',
  LegStateCANCELLED_WITH_ERRORSBrand
>;
export type LegStateCANCELLED_WITH_ERRORSC = t.BrandC<
  t.IntersectionC<[typeof LegState, t.LiteralC<'CANCELLED_WITH_ERRORS'>]>,
  LegStateCANCELLED_WITH_ERRORSBrand
>;
export const LegStateCANCELLED_WITH_ERRORS: LegStateCANCELLED_WITH_ERRORSC = t.brand(
  t.intersection([LegState, t.literal('CANCELLED_WITH_ERRORS')]),
  (
    x,
  ): x is t.Branded<
    LegState & 'CANCELLED_WITH_ERRORS',
    LegStateCANCELLED_WITH_ERRORSBrand
  > => true,
  'LegStateCANCELLED_WITH_ERRORS',
);
export interface LegStateCANCELLED_WITH_ERRORSBrand {
  readonly LegStateCANCELLED_WITH_ERRORS: unique symbol;
}
/** require('io-ts-validator').validator(LegStateCANCELLED_WITH_ERRORS).decodeSync(defaultLegStateCANCELLED_WITH_ERRORS) // => defaultLegStateCANCELLED_WITH_ERRORS */
export const defaultLegStateCANCELLED_WITH_ERRORS: LegStateCANCELLED_WITH_ERRORS = ('CANCELLED_WITH_ERRORS' as unknown) as LegStateCANCELLED_WITH_ERRORS;

// LegStateFINISHED
// The purpose of this remains a mystery
export type LegStateFINISHED = t.Branded<LegState & 'FINISHED', LegStateFINISHEDBrand>;
export type LegStateFINISHEDC = t.BrandC<
  t.IntersectionC<[typeof LegState, t.LiteralC<'FINISHED'>]>,
  LegStateFINISHEDBrand
>;
export const LegStateFINISHED: LegStateFINISHEDC = t.brand(
  t.intersection([LegState, t.literal('FINISHED')]),
  (x): x is t.Branded<LegState & 'FINISHED', LegStateFINISHEDBrand> => true,
  'LegStateFINISHED',
);
export interface LegStateFINISHEDBrand {
  readonly LegStateFINISHED: unique symbol;
}
/** require('io-ts-validator').validator(LegStateFINISHED).decodeSync(defaultLegStateFINISHED) // => defaultLegStateFINISHED */
export const defaultLegStateFINISHED: LegStateFINISHED = ('FINISHED' as unknown) as LegStateFINISHED;

// ItineraryState
// The life-cycle state of an itinerary
export type ItineraryState = t.Branded<
  string &
    (
      | 'START'
      | 'PLANNED'
      | 'PAID'
      | 'ACTIVATED'
      | 'CANCELLED'
      | 'CANCELLED_WITH_ERRORS'
      | 'FINISHED'
    ),
  ItineraryStateBrand
>;
export type ItineraryStateC = t.BrandC<
  t.IntersectionC<
    [
      t.StringC,
      t.UnionC<
        [
          t.LiteralC<'START'>,
          t.LiteralC<'PLANNED'>,
          t.LiteralC<'PAID'>,
          t.LiteralC<'ACTIVATED'>,
          t.LiteralC<'CANCELLED'>,
          t.LiteralC<'CANCELLED_WITH_ERRORS'>,
          t.LiteralC<'FINISHED'>,
        ]
      >,
    ]
  >,
  ItineraryStateBrand
>;
export const ItineraryState: ItineraryStateC = t.brand(
  t.intersection([
    t.string,
    t.union([
      t.literal('START'),
      t.literal('PLANNED'),
      t.literal('PAID'),
      t.literal('ACTIVATED'),
      t.literal('CANCELLED'),
      t.literal('CANCELLED_WITH_ERRORS'),
      t.literal('FINISHED'),
    ]),
  ]),
  (
    x,
  ): x is t.Branded<
    string &
      (
        | 'START'
        | 'PLANNED'
        | 'PAID'
        | 'ACTIVATED'
        | 'CANCELLED'
        | 'CANCELLED_WITH_ERRORS'
        | 'FINISHED'
      ),
    ItineraryStateBrand
  > => true,
  'ItineraryState',
);
export interface ItineraryStateBrand {
  readonly ItineraryState: unique symbol;
}

// ItineraryStateSTART
// The purpose of this remains a mystery
export type ItineraryStateSTART = t.Branded<
  ItineraryState & 'START',
  ItineraryStateSTARTBrand
>;
export type ItineraryStateSTARTC = t.BrandC<
  t.IntersectionC<[typeof ItineraryState, t.LiteralC<'START'>]>,
  ItineraryStateSTARTBrand
>;
export const ItineraryStateSTART: ItineraryStateSTARTC = t.brand(
  t.intersection([ItineraryState, t.literal('START')]),
  (x): x is t.Branded<ItineraryState & 'START', ItineraryStateSTARTBrand> => true,
  'ItineraryStateSTART',
);
export interface ItineraryStateSTARTBrand {
  readonly ItineraryStateSTART: unique symbol;
}
/** require('io-ts-validator').validator(ItineraryStateSTART).decodeSync(defaultItineraryStateSTART) // => defaultItineraryStateSTART */
export const defaultItineraryStateSTART: ItineraryStateSTART = ('START' as unknown) as ItineraryStateSTART;

// ItineraryStatePLANNED
// The purpose of this remains a mystery
export type ItineraryStatePLANNED = t.Branded<
  ItineraryState & 'PLANNED',
  ItineraryStatePLANNEDBrand
>;
export type ItineraryStatePLANNEDC = t.BrandC<
  t.IntersectionC<[typeof ItineraryState, t.LiteralC<'PLANNED'>]>,
  ItineraryStatePLANNEDBrand
>;
export const ItineraryStatePLANNED: ItineraryStatePLANNEDC = t.brand(
  t.intersection([ItineraryState, t.literal('PLANNED')]),
  (x): x is t.Branded<ItineraryState & 'PLANNED', ItineraryStatePLANNEDBrand> => true,
  'ItineraryStatePLANNED',
);
export interface ItineraryStatePLANNEDBrand {
  readonly ItineraryStatePLANNED: unique symbol;
}
/** require('io-ts-validator').validator(ItineraryStatePLANNED).decodeSync(defaultItineraryStatePLANNED) // => defaultItineraryStatePLANNED */
export const defaultItineraryStatePLANNED: ItineraryStatePLANNED = ('PLANNED' as unknown) as ItineraryStatePLANNED;

// ItineraryStatePAID
// The purpose of this remains a mystery
export type ItineraryStatePAID = t.Branded<
  ItineraryState & 'PAID',
  ItineraryStatePAIDBrand
>;
export type ItineraryStatePAIDC = t.BrandC<
  t.IntersectionC<[typeof ItineraryState, t.LiteralC<'PAID'>]>,
  ItineraryStatePAIDBrand
>;
export const ItineraryStatePAID: ItineraryStatePAIDC = t.brand(
  t.intersection([ItineraryState, t.literal('PAID')]),
  (x): x is t.Branded<ItineraryState & 'PAID', ItineraryStatePAIDBrand> => true,
  'ItineraryStatePAID',
);
export interface ItineraryStatePAIDBrand {
  readonly ItineraryStatePAID: unique symbol;
}
/** require('io-ts-validator').validator(ItineraryStatePAID).decodeSync(defaultItineraryStatePAID) // => defaultItineraryStatePAID */
export const defaultItineraryStatePAID: ItineraryStatePAID = ('PAID' as unknown) as ItineraryStatePAID;

// ItineraryStateACTIVATED
// The purpose of this remains a mystery
export type ItineraryStateACTIVATED = t.Branded<
  ItineraryState & 'ACTIVATED',
  ItineraryStateACTIVATEDBrand
>;
export type ItineraryStateACTIVATEDC = t.BrandC<
  t.IntersectionC<[typeof ItineraryState, t.LiteralC<'ACTIVATED'>]>,
  ItineraryStateACTIVATEDBrand
>;
export const ItineraryStateACTIVATED: ItineraryStateACTIVATEDC = t.brand(
  t.intersection([ItineraryState, t.literal('ACTIVATED')]),
  (x): x is t.Branded<ItineraryState & 'ACTIVATED', ItineraryStateACTIVATEDBrand> => true,
  'ItineraryStateACTIVATED',
);
export interface ItineraryStateACTIVATEDBrand {
  readonly ItineraryStateACTIVATED: unique symbol;
}
/** require('io-ts-validator').validator(ItineraryStateACTIVATED).decodeSync(defaultItineraryStateACTIVATED) // => defaultItineraryStateACTIVATED */
export const defaultItineraryStateACTIVATED: ItineraryStateACTIVATED = ('ACTIVATED' as unknown) as ItineraryStateACTIVATED;

// ItineraryStateCANCELLED
// The purpose of this remains a mystery
export type ItineraryStateCANCELLED = t.Branded<
  ItineraryState & 'CANCELLED',
  ItineraryStateCANCELLEDBrand
>;
export type ItineraryStateCANCELLEDC = t.BrandC<
  t.IntersectionC<[typeof ItineraryState, t.LiteralC<'CANCELLED'>]>,
  ItineraryStateCANCELLEDBrand
>;
export const ItineraryStateCANCELLED: ItineraryStateCANCELLEDC = t.brand(
  t.intersection([ItineraryState, t.literal('CANCELLED')]),
  (x): x is t.Branded<ItineraryState & 'CANCELLED', ItineraryStateCANCELLEDBrand> => true,
  'ItineraryStateCANCELLED',
);
export interface ItineraryStateCANCELLEDBrand {
  readonly ItineraryStateCANCELLED: unique symbol;
}
/** require('io-ts-validator').validator(ItineraryStateCANCELLED).decodeSync(defaultItineraryStateCANCELLED) // => defaultItineraryStateCANCELLED */
export const defaultItineraryStateCANCELLED: ItineraryStateCANCELLED = ('CANCELLED' as unknown) as ItineraryStateCANCELLED;

// ItineraryStateCANCELLED_WITH_ERRORS
// The purpose of this remains a mystery
export type ItineraryStateCANCELLED_WITH_ERRORS = t.Branded<
  ItineraryState & 'CANCELLED_WITH_ERRORS',
  ItineraryStateCANCELLED_WITH_ERRORSBrand
>;
export type ItineraryStateCANCELLED_WITH_ERRORSC = t.BrandC<
  t.IntersectionC<[typeof ItineraryState, t.LiteralC<'CANCELLED_WITH_ERRORS'>]>,
  ItineraryStateCANCELLED_WITH_ERRORSBrand
>;
export const ItineraryStateCANCELLED_WITH_ERRORS: ItineraryStateCANCELLED_WITH_ERRORSC = t.brand(
  t.intersection([ItineraryState, t.literal('CANCELLED_WITH_ERRORS')]),
  (
    x,
  ): x is t.Branded<
    ItineraryState & 'CANCELLED_WITH_ERRORS',
    ItineraryStateCANCELLED_WITH_ERRORSBrand
  > => true,
  'ItineraryStateCANCELLED_WITH_ERRORS',
);
export interface ItineraryStateCANCELLED_WITH_ERRORSBrand {
  readonly ItineraryStateCANCELLED_WITH_ERRORS: unique symbol;
}
/** require('io-ts-validator').validator(ItineraryStateCANCELLED_WITH_ERRORS).decodeSync(defaultItineraryStateCANCELLED_WITH_ERRORS) // => defaultItineraryStateCANCELLED_WITH_ERRORS */
export const defaultItineraryStateCANCELLED_WITH_ERRORS: ItineraryStateCANCELLED_WITH_ERRORS = ('CANCELLED_WITH_ERRORS' as unknown) as ItineraryStateCANCELLED_WITH_ERRORS;

// ItineraryStateFINISHED
// The purpose of this remains a mystery
export type ItineraryStateFINISHED = t.Branded<
  ItineraryState & 'FINISHED',
  ItineraryStateFINISHEDBrand
>;
export type ItineraryStateFINISHEDC = t.BrandC<
  t.IntersectionC<[typeof ItineraryState, t.LiteralC<'FINISHED'>]>,
  ItineraryStateFINISHEDBrand
>;
export const ItineraryStateFINISHED: ItineraryStateFINISHEDC = t.brand(
  t.intersection([ItineraryState, t.literal('FINISHED')]),
  (x): x is t.Branded<ItineraryState & 'FINISHED', ItineraryStateFINISHEDBrand> => true,
  'ItineraryStateFINISHED',
);
export interface ItineraryStateFINISHEDBrand {
  readonly ItineraryStateFINISHED: unique symbol;
}
/** require('io-ts-validator').validator(ItineraryStateFINISHED).decodeSync(defaultItineraryStateFINISHED) // => defaultItineraryStateFINISHED */
export const defaultItineraryStateFINISHED: ItineraryStateFINISHED = ('FINISHED' as unknown) as ItineraryStateFINISHED;

// SubscriptionIntentState
// The life-cycle state of an subscription intent
export type SubscriptionIntentState = t.Branded<
  string &
    (
      | 'START'
      | 'DETAILS'
      | 'CUSTOMISATION'
      | 'PAYMENT'
      | 'VERIFICATION'
      | 'AUTH'
      | 'CANCELLED'
      | 'CANCELLED_WITH_ERRORS'
      | 'FINISHED'
    ),
  SubscriptionIntentStateBrand
>;
export type SubscriptionIntentStateC = t.BrandC<
  t.IntersectionC<
    [
      t.StringC,
      t.UnionC<
        [
          t.LiteralC<'START'>,
          t.LiteralC<'DETAILS'>,
          t.LiteralC<'CUSTOMISATION'>,
          t.LiteralC<'PAYMENT'>,
          t.LiteralC<'VERIFICATION'>,
          t.LiteralC<'AUTH'>,
          t.LiteralC<'CANCELLED'>,
          t.LiteralC<'CANCELLED_WITH_ERRORS'>,
          t.LiteralC<'FINISHED'>,
        ]
      >,
    ]
  >,
  SubscriptionIntentStateBrand
>;
export const SubscriptionIntentState: SubscriptionIntentStateC = t.brand(
  t.intersection([
    t.string,
    t.union([
      t.literal('START'),
      t.literal('DETAILS'),
      t.literal('CUSTOMISATION'),
      t.literal('PAYMENT'),
      t.literal('VERIFICATION'),
      t.literal('AUTH'),
      t.literal('CANCELLED'),
      t.literal('CANCELLED_WITH_ERRORS'),
      t.literal('FINISHED'),
    ]),
  ]),
  (
    x,
  ): x is t.Branded<
    string &
      (
        | 'START'
        | 'DETAILS'
        | 'CUSTOMISATION'
        | 'PAYMENT'
        | 'VERIFICATION'
        | 'AUTH'
        | 'CANCELLED'
        | 'CANCELLED_WITH_ERRORS'
        | 'FINISHED'
      ),
    SubscriptionIntentStateBrand
  > => true,
  'SubscriptionIntentState',
);
export interface SubscriptionIntentStateBrand {
  readonly SubscriptionIntentState: unique symbol;
}

// SubscriptionIntentStateSTART
// The purpose of this remains a mystery
export type SubscriptionIntentStateSTART = t.Branded<
  SubscriptionIntentState & 'START',
  SubscriptionIntentStateSTARTBrand
>;
export type SubscriptionIntentStateSTARTC = t.BrandC<
  t.IntersectionC<[typeof SubscriptionIntentState, t.LiteralC<'START'>]>,
  SubscriptionIntentStateSTARTBrand
>;
export const SubscriptionIntentStateSTART: SubscriptionIntentStateSTARTC = t.brand(
  t.intersection([SubscriptionIntentState, t.literal('START')]),
  (
    x,
  ): x is t.Branded<
    SubscriptionIntentState & 'START',
    SubscriptionIntentStateSTARTBrand
  > => true,
  'SubscriptionIntentStateSTART',
);
export interface SubscriptionIntentStateSTARTBrand {
  readonly SubscriptionIntentStateSTART: unique symbol;
}
/** require('io-ts-validator').validator(SubscriptionIntentStateSTART).decodeSync(defaultSubscriptionIntentStateSTART) // => defaultSubscriptionIntentStateSTART */
export const defaultSubscriptionIntentStateSTART: SubscriptionIntentStateSTART = ('START' as unknown) as SubscriptionIntentStateSTART;

// SubscriptionIntentStateDETAILS
// The purpose of this remains a mystery
export type SubscriptionIntentStateDETAILS = t.Branded<
  SubscriptionIntentState & 'DETAILS',
  SubscriptionIntentStateDETAILSBrand
>;
export type SubscriptionIntentStateDETAILSC = t.BrandC<
  t.IntersectionC<[typeof SubscriptionIntentState, t.LiteralC<'DETAILS'>]>,
  SubscriptionIntentStateDETAILSBrand
>;
export const SubscriptionIntentStateDETAILS: SubscriptionIntentStateDETAILSC = t.brand(
  t.intersection([SubscriptionIntentState, t.literal('DETAILS')]),
  (
    x,
  ): x is t.Branded<
    SubscriptionIntentState & 'DETAILS',
    SubscriptionIntentStateDETAILSBrand
  > => true,
  'SubscriptionIntentStateDETAILS',
);
export interface SubscriptionIntentStateDETAILSBrand {
  readonly SubscriptionIntentStateDETAILS: unique symbol;
}
/** require('io-ts-validator').validator(SubscriptionIntentStateDETAILS).decodeSync(defaultSubscriptionIntentStateDETAILS) // => defaultSubscriptionIntentStateDETAILS */
export const defaultSubscriptionIntentStateDETAILS: SubscriptionIntentStateDETAILS = ('DETAILS' as unknown) as SubscriptionIntentStateDETAILS;

// SubscriptionIntentStateCUSTOMISATION
// The purpose of this remains a mystery
export type SubscriptionIntentStateCUSTOMISATION = t.Branded<
  SubscriptionIntentState & 'CUSTOMISATION',
  SubscriptionIntentStateCUSTOMISATIONBrand
>;
export type SubscriptionIntentStateCUSTOMISATIONC = t.BrandC<
  t.IntersectionC<[typeof SubscriptionIntentState, t.LiteralC<'CUSTOMISATION'>]>,
  SubscriptionIntentStateCUSTOMISATIONBrand
>;
export const SubscriptionIntentStateCUSTOMISATION: SubscriptionIntentStateCUSTOMISATIONC = t.brand(
  t.intersection([SubscriptionIntentState, t.literal('CUSTOMISATION')]),
  (
    x,
  ): x is t.Branded<
    SubscriptionIntentState & 'CUSTOMISATION',
    SubscriptionIntentStateCUSTOMISATIONBrand
  > => true,
  'SubscriptionIntentStateCUSTOMISATION',
);
export interface SubscriptionIntentStateCUSTOMISATIONBrand {
  readonly SubscriptionIntentStateCUSTOMISATION: unique symbol;
}
/** require('io-ts-validator').validator(SubscriptionIntentStateCUSTOMISATION).decodeSync(defaultSubscriptionIntentStateCUSTOMISATION) // => defaultSubscriptionIntentStateCUSTOMISATION */
export const defaultSubscriptionIntentStateCUSTOMISATION: SubscriptionIntentStateCUSTOMISATION = ('CUSTOMISATION' as unknown) as SubscriptionIntentStateCUSTOMISATION;

// SubscriptionIntentStatePAYMENT
// The purpose of this remains a mystery
export type SubscriptionIntentStatePAYMENT = t.Branded<
  SubscriptionIntentState & 'PAYMENT',
  SubscriptionIntentStatePAYMENTBrand
>;
export type SubscriptionIntentStatePAYMENTC = t.BrandC<
  t.IntersectionC<[typeof SubscriptionIntentState, t.LiteralC<'PAYMENT'>]>,
  SubscriptionIntentStatePAYMENTBrand
>;
export const SubscriptionIntentStatePAYMENT: SubscriptionIntentStatePAYMENTC = t.brand(
  t.intersection([SubscriptionIntentState, t.literal('PAYMENT')]),
  (
    x,
  ): x is t.Branded<
    SubscriptionIntentState & 'PAYMENT',
    SubscriptionIntentStatePAYMENTBrand
  > => true,
  'SubscriptionIntentStatePAYMENT',
);
export interface SubscriptionIntentStatePAYMENTBrand {
  readonly SubscriptionIntentStatePAYMENT: unique symbol;
}
/** require('io-ts-validator').validator(SubscriptionIntentStatePAYMENT).decodeSync(defaultSubscriptionIntentStatePAYMENT) // => defaultSubscriptionIntentStatePAYMENT */
export const defaultSubscriptionIntentStatePAYMENT: SubscriptionIntentStatePAYMENT = ('PAYMENT' as unknown) as SubscriptionIntentStatePAYMENT;

// SubscriptionIntentStateVERIFICATION
// The purpose of this remains a mystery
export type SubscriptionIntentStateVERIFICATION = t.Branded<
  SubscriptionIntentState & 'VERIFICATION',
  SubscriptionIntentStateVERIFICATIONBrand
>;
export type SubscriptionIntentStateVERIFICATIONC = t.BrandC<
  t.IntersectionC<[typeof SubscriptionIntentState, t.LiteralC<'VERIFICATION'>]>,
  SubscriptionIntentStateVERIFICATIONBrand
>;
export const SubscriptionIntentStateVERIFICATION: SubscriptionIntentStateVERIFICATIONC = t.brand(
  t.intersection([SubscriptionIntentState, t.literal('VERIFICATION')]),
  (
    x,
  ): x is t.Branded<
    SubscriptionIntentState & 'VERIFICATION',
    SubscriptionIntentStateVERIFICATIONBrand
  > => true,
  'SubscriptionIntentStateVERIFICATION',
);
export interface SubscriptionIntentStateVERIFICATIONBrand {
  readonly SubscriptionIntentStateVERIFICATION: unique symbol;
}
/** require('io-ts-validator').validator(SubscriptionIntentStateVERIFICATION).decodeSync(defaultSubscriptionIntentStateVERIFICATION) // => defaultSubscriptionIntentStateVERIFICATION */
export const defaultSubscriptionIntentStateVERIFICATION: SubscriptionIntentStateVERIFICATION = ('VERIFICATION' as unknown) as SubscriptionIntentStateVERIFICATION;

// SubscriptionIntentStateAUTH
// The purpose of this remains a mystery
export type SubscriptionIntentStateAUTH = t.Branded<
  SubscriptionIntentState & 'AUTH',
  SubscriptionIntentStateAUTHBrand
>;
export type SubscriptionIntentStateAUTHC = t.BrandC<
  t.IntersectionC<[typeof SubscriptionIntentState, t.LiteralC<'AUTH'>]>,
  SubscriptionIntentStateAUTHBrand
>;
export const SubscriptionIntentStateAUTH: SubscriptionIntentStateAUTHC = t.brand(
  t.intersection([SubscriptionIntentState, t.literal('AUTH')]),
  (
    x,
  ): x is t.Branded<SubscriptionIntentState & 'AUTH', SubscriptionIntentStateAUTHBrand> =>
    true,
  'SubscriptionIntentStateAUTH',
);
export interface SubscriptionIntentStateAUTHBrand {
  readonly SubscriptionIntentStateAUTH: unique symbol;
}
/** require('io-ts-validator').validator(SubscriptionIntentStateAUTH).decodeSync(defaultSubscriptionIntentStateAUTH) // => defaultSubscriptionIntentStateAUTH */
export const defaultSubscriptionIntentStateAUTH: SubscriptionIntentStateAUTH = ('AUTH' as unknown) as SubscriptionIntentStateAUTH;

// SubscriptionIntentStateCANCELLED
// The purpose of this remains a mystery
export type SubscriptionIntentStateCANCELLED = t.Branded<
  SubscriptionIntentState & 'CANCELLED',
  SubscriptionIntentStateCANCELLEDBrand
>;
export type SubscriptionIntentStateCANCELLEDC = t.BrandC<
  t.IntersectionC<[typeof SubscriptionIntentState, t.LiteralC<'CANCELLED'>]>,
  SubscriptionIntentStateCANCELLEDBrand
>;
export const SubscriptionIntentStateCANCELLED: SubscriptionIntentStateCANCELLEDC = t.brand(
  t.intersection([SubscriptionIntentState, t.literal('CANCELLED')]),
  (
    x,
  ): x is t.Branded<
    SubscriptionIntentState & 'CANCELLED',
    SubscriptionIntentStateCANCELLEDBrand
  > => true,
  'SubscriptionIntentStateCANCELLED',
);
export interface SubscriptionIntentStateCANCELLEDBrand {
  readonly SubscriptionIntentStateCANCELLED: unique symbol;
}
/** require('io-ts-validator').validator(SubscriptionIntentStateCANCELLED).decodeSync(defaultSubscriptionIntentStateCANCELLED) // => defaultSubscriptionIntentStateCANCELLED */
export const defaultSubscriptionIntentStateCANCELLED: SubscriptionIntentStateCANCELLED = ('CANCELLED' as unknown) as SubscriptionIntentStateCANCELLED;

// SubscriptionIntentStateCANCELLED_WITH_ERRORS
// The purpose of this remains a mystery
export type SubscriptionIntentStateCANCELLED_WITH_ERRORS = t.Branded<
  SubscriptionIntentState & 'CANCELLED_WITH_ERRORS',
  SubscriptionIntentStateCANCELLED_WITH_ERRORSBrand
>;
export type SubscriptionIntentStateCANCELLED_WITH_ERRORSC = t.BrandC<
  t.IntersectionC<[typeof SubscriptionIntentState, t.LiteralC<'CANCELLED_WITH_ERRORS'>]>,
  SubscriptionIntentStateCANCELLED_WITH_ERRORSBrand
>;
export const SubscriptionIntentStateCANCELLED_WITH_ERRORS: SubscriptionIntentStateCANCELLED_WITH_ERRORSC = t.brand(
  t.intersection([SubscriptionIntentState, t.literal('CANCELLED_WITH_ERRORS')]),
  (
    x,
  ): x is t.Branded<
    SubscriptionIntentState & 'CANCELLED_WITH_ERRORS',
    SubscriptionIntentStateCANCELLED_WITH_ERRORSBrand
  > => true,
  'SubscriptionIntentStateCANCELLED_WITH_ERRORS',
);
export interface SubscriptionIntentStateCANCELLED_WITH_ERRORSBrand {
  readonly SubscriptionIntentStateCANCELLED_WITH_ERRORS: unique symbol;
}
/** require('io-ts-validator').validator(SubscriptionIntentStateCANCELLED_WITH_ERRORS).decodeSync(defaultSubscriptionIntentStateCANCELLED_WITH_ERRORS) // => defaultSubscriptionIntentStateCANCELLED_WITH_ERRORS */
export const defaultSubscriptionIntentStateCANCELLED_WITH_ERRORS: SubscriptionIntentStateCANCELLED_WITH_ERRORS = ('CANCELLED_WITH_ERRORS' as unknown) as SubscriptionIntentStateCANCELLED_WITH_ERRORS;

// SubscriptionIntentStateFINISHED
// The purpose of this remains a mystery
export type SubscriptionIntentStateFINISHED = t.Branded<
  SubscriptionIntentState & 'FINISHED',
  SubscriptionIntentStateFINISHEDBrand
>;
export type SubscriptionIntentStateFINISHEDC = t.BrandC<
  t.IntersectionC<[typeof SubscriptionIntentState, t.LiteralC<'FINISHED'>]>,
  SubscriptionIntentStateFINISHEDBrand
>;
export const SubscriptionIntentStateFINISHED: SubscriptionIntentStateFINISHEDC = t.brand(
  t.intersection([SubscriptionIntentState, t.literal('FINISHED')]),
  (
    x,
  ): x is t.Branded<
    SubscriptionIntentState & 'FINISHED',
    SubscriptionIntentStateFINISHEDBrand
  > => true,
  'SubscriptionIntentStateFINISHED',
);
export interface SubscriptionIntentStateFINISHEDBrand {
  readonly SubscriptionIntentStateFINISHED: unique symbol;
}
/** require('io-ts-validator').validator(SubscriptionIntentStateFINISHED).decodeSync(defaultSubscriptionIntentStateFINISHED) // => defaultSubscriptionIntentStateFINISHED */
export const defaultSubscriptionIntentStateFINISHED: SubscriptionIntentStateFINISHED = ('FINISHED' as unknown) as SubscriptionIntentStateFINISHED;

// VerificationState
// The life-cycle state of a verification
export type VerificationState = t.Branded<
  string &
    (
      | 'START'
      | 'PENDING'
      | 'STARTED'
      | 'SUBMITTED'
      | 'APPROVED'
      | 'DECLINED'
      | 'EXPIRED'
      | 'RESUBMISSION_REQUESTED'
      | 'ABANDONED'
    ),
  VerificationStateBrand
>;
export type VerificationStateC = t.BrandC<
  t.IntersectionC<
    [
      t.StringC,
      t.UnionC<
        [
          t.LiteralC<'START'>,
          t.LiteralC<'PENDING'>,
          t.LiteralC<'STARTED'>,
          t.LiteralC<'SUBMITTED'>,
          t.LiteralC<'APPROVED'>,
          t.LiteralC<'DECLINED'>,
          t.LiteralC<'EXPIRED'>,
          t.LiteralC<'RESUBMISSION_REQUESTED'>,
          t.LiteralC<'ABANDONED'>,
        ]
      >,
    ]
  >,
  VerificationStateBrand
>;
export const VerificationState: VerificationStateC = t.brand(
  t.intersection([
    t.string,
    t.union([
      t.literal('START'),
      t.literal('PENDING'),
      t.literal('STARTED'),
      t.literal('SUBMITTED'),
      t.literal('APPROVED'),
      t.literal('DECLINED'),
      t.literal('EXPIRED'),
      t.literal('RESUBMISSION_REQUESTED'),
      t.literal('ABANDONED'),
    ]),
  ]),
  (
    x,
  ): x is t.Branded<
    string &
      (
        | 'START'
        | 'PENDING'
        | 'STARTED'
        | 'SUBMITTED'
        | 'APPROVED'
        | 'DECLINED'
        | 'EXPIRED'
        | 'RESUBMISSION_REQUESTED'
        | 'ABANDONED'
      ),
    VerificationStateBrand
  > => true,
  'VerificationState',
);
export interface VerificationStateBrand {
  readonly VerificationState: unique symbol;
}

// VerificationStateSTART
// The purpose of this remains a mystery
export type VerificationStateSTART = t.Branded<
  VerificationState & 'START',
  VerificationStateSTARTBrand
>;
export type VerificationStateSTARTC = t.BrandC<
  t.IntersectionC<[typeof VerificationState, t.LiteralC<'START'>]>,
  VerificationStateSTARTBrand
>;
export const VerificationStateSTART: VerificationStateSTARTC = t.brand(
  t.intersection([VerificationState, t.literal('START')]),
  (x): x is t.Branded<VerificationState & 'START', VerificationStateSTARTBrand> => true,
  'VerificationStateSTART',
);
export interface VerificationStateSTARTBrand {
  readonly VerificationStateSTART: unique symbol;
}
/** require('io-ts-validator').validator(VerificationStateSTART).decodeSync(defaultVerificationStateSTART) // => defaultVerificationStateSTART */
export const defaultVerificationStateSTART: VerificationStateSTART = ('START' as unknown) as VerificationStateSTART;

// VerificationStatePENDING
// The purpose of this remains a mystery
export type VerificationStatePENDING = t.Branded<
  VerificationState & 'PENDING',
  VerificationStatePENDINGBrand
>;
export type VerificationStatePENDINGC = t.BrandC<
  t.IntersectionC<[typeof VerificationState, t.LiteralC<'PENDING'>]>,
  VerificationStatePENDINGBrand
>;
export const VerificationStatePENDING: VerificationStatePENDINGC = t.brand(
  t.intersection([VerificationState, t.literal('PENDING')]),
  (x): x is t.Branded<VerificationState & 'PENDING', VerificationStatePENDINGBrand> =>
    true,
  'VerificationStatePENDING',
);
export interface VerificationStatePENDINGBrand {
  readonly VerificationStatePENDING: unique symbol;
}
/** require('io-ts-validator').validator(VerificationStatePENDING).decodeSync(defaultVerificationStatePENDING) // => defaultVerificationStatePENDING */
export const defaultVerificationStatePENDING: VerificationStatePENDING = ('PENDING' as unknown) as VerificationStatePENDING;

// VerificationStateSTARTED
// The purpose of this remains a mystery
export type VerificationStateSTARTED = t.Branded<
  VerificationState & 'STARTED',
  VerificationStateSTARTEDBrand
>;
export type VerificationStateSTARTEDC = t.BrandC<
  t.IntersectionC<[typeof VerificationState, t.LiteralC<'STARTED'>]>,
  VerificationStateSTARTEDBrand
>;
export const VerificationStateSTARTED: VerificationStateSTARTEDC = t.brand(
  t.intersection([VerificationState, t.literal('STARTED')]),
  (x): x is t.Branded<VerificationState & 'STARTED', VerificationStateSTARTEDBrand> =>
    true,
  'VerificationStateSTARTED',
);
export interface VerificationStateSTARTEDBrand {
  readonly VerificationStateSTARTED: unique symbol;
}
/** require('io-ts-validator').validator(VerificationStateSTARTED).decodeSync(defaultVerificationStateSTARTED) // => defaultVerificationStateSTARTED */
export const defaultVerificationStateSTARTED: VerificationStateSTARTED = ('STARTED' as unknown) as VerificationStateSTARTED;

// VerificationStateSUBMITTED
// The purpose of this remains a mystery
export type VerificationStateSUBMITTED = t.Branded<
  VerificationState & 'SUBMITTED',
  VerificationStateSUBMITTEDBrand
>;
export type VerificationStateSUBMITTEDC = t.BrandC<
  t.IntersectionC<[typeof VerificationState, t.LiteralC<'SUBMITTED'>]>,
  VerificationStateSUBMITTEDBrand
>;
export const VerificationStateSUBMITTED: VerificationStateSUBMITTEDC = t.brand(
  t.intersection([VerificationState, t.literal('SUBMITTED')]),
  (x): x is t.Branded<VerificationState & 'SUBMITTED', VerificationStateSUBMITTEDBrand> =>
    true,
  'VerificationStateSUBMITTED',
);
export interface VerificationStateSUBMITTEDBrand {
  readonly VerificationStateSUBMITTED: unique symbol;
}
/** require('io-ts-validator').validator(VerificationStateSUBMITTED).decodeSync(defaultVerificationStateSUBMITTED) // => defaultVerificationStateSUBMITTED */
export const defaultVerificationStateSUBMITTED: VerificationStateSUBMITTED = ('SUBMITTED' as unknown) as VerificationStateSUBMITTED;

// VerificationStateAPPROVED
// The purpose of this remains a mystery
export type VerificationStateAPPROVED = t.Branded<
  VerificationState & 'APPROVED',
  VerificationStateAPPROVEDBrand
>;
export type VerificationStateAPPROVEDC = t.BrandC<
  t.IntersectionC<[typeof VerificationState, t.LiteralC<'APPROVED'>]>,
  VerificationStateAPPROVEDBrand
>;
export const VerificationStateAPPROVED: VerificationStateAPPROVEDC = t.brand(
  t.intersection([VerificationState, t.literal('APPROVED')]),
  (x): x is t.Branded<VerificationState & 'APPROVED', VerificationStateAPPROVEDBrand> =>
    true,
  'VerificationStateAPPROVED',
);
export interface VerificationStateAPPROVEDBrand {
  readonly VerificationStateAPPROVED: unique symbol;
}
/** require('io-ts-validator').validator(VerificationStateAPPROVED).decodeSync(defaultVerificationStateAPPROVED) // => defaultVerificationStateAPPROVED */
export const defaultVerificationStateAPPROVED: VerificationStateAPPROVED = ('APPROVED' as unknown) as VerificationStateAPPROVED;

// VerificationStateDECLINED
// The purpose of this remains a mystery
export type VerificationStateDECLINED = t.Branded<
  VerificationState & 'DECLINED',
  VerificationStateDECLINEDBrand
>;
export type VerificationStateDECLINEDC = t.BrandC<
  t.IntersectionC<[typeof VerificationState, t.LiteralC<'DECLINED'>]>,
  VerificationStateDECLINEDBrand
>;
export const VerificationStateDECLINED: VerificationStateDECLINEDC = t.brand(
  t.intersection([VerificationState, t.literal('DECLINED')]),
  (x): x is t.Branded<VerificationState & 'DECLINED', VerificationStateDECLINEDBrand> =>
    true,
  'VerificationStateDECLINED',
);
export interface VerificationStateDECLINEDBrand {
  readonly VerificationStateDECLINED: unique symbol;
}
/** require('io-ts-validator').validator(VerificationStateDECLINED).decodeSync(defaultVerificationStateDECLINED) // => defaultVerificationStateDECLINED */
export const defaultVerificationStateDECLINED: VerificationStateDECLINED = ('DECLINED' as unknown) as VerificationStateDECLINED;

// VerificationStateEXPIRED
// The purpose of this remains a mystery
export type VerificationStateEXPIRED = t.Branded<
  VerificationState & 'EXPIRED',
  VerificationStateEXPIREDBrand
>;
export type VerificationStateEXPIREDC = t.BrandC<
  t.IntersectionC<[typeof VerificationState, t.LiteralC<'EXPIRED'>]>,
  VerificationStateEXPIREDBrand
>;
export const VerificationStateEXPIRED: VerificationStateEXPIREDC = t.brand(
  t.intersection([VerificationState, t.literal('EXPIRED')]),
  (x): x is t.Branded<VerificationState & 'EXPIRED', VerificationStateEXPIREDBrand> =>
    true,
  'VerificationStateEXPIRED',
);
export interface VerificationStateEXPIREDBrand {
  readonly VerificationStateEXPIRED: unique symbol;
}
/** require('io-ts-validator').validator(VerificationStateEXPIRED).decodeSync(defaultVerificationStateEXPIRED) // => defaultVerificationStateEXPIRED */
export const defaultVerificationStateEXPIRED: VerificationStateEXPIRED = ('EXPIRED' as unknown) as VerificationStateEXPIRED;

// VerificationStateRESUBMISSION_REQUESTED
// The purpose of this remains a mystery
export type VerificationStateRESUBMISSION_REQUESTED = t.Branded<
  VerificationState & 'RESUBMISSION_REQUESTED',
  VerificationStateRESUBMISSION_REQUESTEDBrand
>;
export type VerificationStateRESUBMISSION_REQUESTEDC = t.BrandC<
  t.IntersectionC<[typeof VerificationState, t.LiteralC<'RESUBMISSION_REQUESTED'>]>,
  VerificationStateRESUBMISSION_REQUESTEDBrand
>;
export const VerificationStateRESUBMISSION_REQUESTED: VerificationStateRESUBMISSION_REQUESTEDC = t.brand(
  t.intersection([VerificationState, t.literal('RESUBMISSION_REQUESTED')]),
  (
    x,
  ): x is t.Branded<
    VerificationState & 'RESUBMISSION_REQUESTED',
    VerificationStateRESUBMISSION_REQUESTEDBrand
  > => true,
  'VerificationStateRESUBMISSION_REQUESTED',
);
export interface VerificationStateRESUBMISSION_REQUESTEDBrand {
  readonly VerificationStateRESUBMISSION_REQUESTED: unique symbol;
}
/** require('io-ts-validator').validator(VerificationStateRESUBMISSION_REQUESTED).decodeSync(defaultVerificationStateRESUBMISSION_REQUESTED) // => defaultVerificationStateRESUBMISSION_REQUESTED */
export const defaultVerificationStateRESUBMISSION_REQUESTED: VerificationStateRESUBMISSION_REQUESTED = ('RESUBMISSION_REQUESTED' as unknown) as VerificationStateRESUBMISSION_REQUESTED;

// VerificationStateABANDONED
// The purpose of this remains a mystery
export type VerificationStateABANDONED = t.Branded<
  VerificationState & 'ABANDONED',
  VerificationStateABANDONEDBrand
>;
export type VerificationStateABANDONEDC = t.BrandC<
  t.IntersectionC<[typeof VerificationState, t.LiteralC<'ABANDONED'>]>,
  VerificationStateABANDONEDBrand
>;
export const VerificationStateABANDONED: VerificationStateABANDONEDC = t.brand(
  t.intersection([VerificationState, t.literal('ABANDONED')]),
  (x): x is t.Branded<VerificationState & 'ABANDONED', VerificationStateABANDONEDBrand> =>
    true,
  'VerificationStateABANDONED',
);
export interface VerificationStateABANDONEDBrand {
  readonly VerificationStateABANDONED: unique symbol;
}
/** require('io-ts-validator').validator(VerificationStateABANDONED).decodeSync(defaultVerificationStateABANDONED) // => defaultVerificationStateABANDONED */
export const defaultVerificationStateABANDONED: VerificationStateABANDONED = ('ABANDONED' as unknown) as VerificationStateABANDONED;

// CheckoutSessionState
// The life-cycle state of a verification
export type CheckoutSessionState = t.Branded<
  string & ('PENDING' | 'FINISHED' | 'REFUNDED'),
  CheckoutSessionStateBrand
>;
export type CheckoutSessionStateC = t.BrandC<
  t.IntersectionC<
    [
      t.StringC,
      t.UnionC<[t.LiteralC<'PENDING'>, t.LiteralC<'FINISHED'>, t.LiteralC<'REFUNDED'>]>,
    ]
  >,
  CheckoutSessionStateBrand
>;
export const CheckoutSessionState: CheckoutSessionStateC = t.brand(
  t.intersection([
    t.string,
    t.union([t.literal('PENDING'), t.literal('FINISHED'), t.literal('REFUNDED')]),
  ]),
  (
    x,
  ): x is t.Branded<
    string & ('PENDING' | 'FINISHED' | 'REFUNDED'),
    CheckoutSessionStateBrand
  > => true,
  'CheckoutSessionState',
);
export interface CheckoutSessionStateBrand {
  readonly CheckoutSessionState: unique symbol;
}

// CheckoutSessionStatePENDING
// The purpose of this remains a mystery
export type CheckoutSessionStatePENDING = t.Branded<
  CheckoutSessionState & 'PENDING',
  CheckoutSessionStatePENDINGBrand
>;
export type CheckoutSessionStatePENDINGC = t.BrandC<
  t.IntersectionC<[typeof CheckoutSessionState, t.LiteralC<'PENDING'>]>,
  CheckoutSessionStatePENDINGBrand
>;
export const CheckoutSessionStatePENDING: CheckoutSessionStatePENDINGC = t.brand(
  t.intersection([CheckoutSessionState, t.literal('PENDING')]),
  (
    x,
  ): x is t.Branded<CheckoutSessionState & 'PENDING', CheckoutSessionStatePENDINGBrand> =>
    true,
  'CheckoutSessionStatePENDING',
);
export interface CheckoutSessionStatePENDINGBrand {
  readonly CheckoutSessionStatePENDING: unique symbol;
}
/** require('io-ts-validator').validator(CheckoutSessionStatePENDING).decodeSync(defaultCheckoutSessionStatePENDING) // => defaultCheckoutSessionStatePENDING */
export const defaultCheckoutSessionStatePENDING: CheckoutSessionStatePENDING = ('PENDING' as unknown) as CheckoutSessionStatePENDING;

// CheckoutSessionStateFINISHED
// The purpose of this remains a mystery
export type CheckoutSessionStateFINISHED = t.Branded<
  CheckoutSessionState & 'FINISHED',
  CheckoutSessionStateFINISHEDBrand
>;
export type CheckoutSessionStateFINISHEDC = t.BrandC<
  t.IntersectionC<[typeof CheckoutSessionState, t.LiteralC<'FINISHED'>]>,
  CheckoutSessionStateFINISHEDBrand
>;
export const CheckoutSessionStateFINISHED: CheckoutSessionStateFINISHEDC = t.brand(
  t.intersection([CheckoutSessionState, t.literal('FINISHED')]),
  (
    x,
  ): x is t.Branded<
    CheckoutSessionState & 'FINISHED',
    CheckoutSessionStateFINISHEDBrand
  > => true,
  'CheckoutSessionStateFINISHED',
);
export interface CheckoutSessionStateFINISHEDBrand {
  readonly CheckoutSessionStateFINISHED: unique symbol;
}
/** require('io-ts-validator').validator(CheckoutSessionStateFINISHED).decodeSync(defaultCheckoutSessionStateFINISHED) // => defaultCheckoutSessionStateFINISHED */
export const defaultCheckoutSessionStateFINISHED: CheckoutSessionStateFINISHED = ('FINISHED' as unknown) as CheckoutSessionStateFINISHED;

// CheckoutSessionStateREFUNDED
// The purpose of this remains a mystery
export type CheckoutSessionStateREFUNDED = t.Branded<
  CheckoutSessionState & 'REFUNDED',
  CheckoutSessionStateREFUNDEDBrand
>;
export type CheckoutSessionStateREFUNDEDC = t.BrandC<
  t.IntersectionC<[typeof CheckoutSessionState, t.LiteralC<'REFUNDED'>]>,
  CheckoutSessionStateREFUNDEDBrand
>;
export const CheckoutSessionStateREFUNDED: CheckoutSessionStateREFUNDEDC = t.brand(
  t.intersection([CheckoutSessionState, t.literal('REFUNDED')]),
  (
    x,
  ): x is t.Branded<
    CheckoutSessionState & 'REFUNDED',
    CheckoutSessionStateREFUNDEDBrand
  > => true,
  'CheckoutSessionStateREFUNDED',
);
export interface CheckoutSessionStateREFUNDEDBrand {
  readonly CheckoutSessionStateREFUNDED: unique symbol;
}
/** require('io-ts-validator').validator(CheckoutSessionStateREFUNDED).decodeSync(defaultCheckoutSessionStateREFUNDED) // => defaultCheckoutSessionStateREFUNDED */
export const defaultCheckoutSessionStateREFUNDED: CheckoutSessionStateREFUNDED = ('REFUNDED' as unknown) as CheckoutSessionStateREFUNDED;

// State
// The default export. More information at the top.
export type State = t.Branded<unknown, StateBrand>;
export type StateC = t.BrandC<t.UnknownC, StateBrand>;
export const State: StateC = t.brand(
  t.unknown,
  (x): x is t.Branded<unknown, StateBrand> => true,
  'State',
);
export interface StateBrand {
  readonly State: unique symbol;
}

export default State;

// Success
