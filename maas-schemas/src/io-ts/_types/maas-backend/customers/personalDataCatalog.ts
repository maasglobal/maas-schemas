/*

undefined
MaaS customer personal data catalog schema

!!! AUTO GENERATED BY IOTSFJS REFRAIN FROM MANUAL EDITING !!!
See https://www.npmjs.com/package/io-ts-from-json-schema

*/

import * as t from 'io-ts';

import * as Region_ad49_ from '../../core/region';

export type Defined = {} | null;
export class DefinedType extends t.Type<Defined> {
  readonly _tag: 'DefinedType' = 'DefinedType';
  constructor() {
    super(
      'defined',
      (u): u is Defined => typeof u !== 'undefined',
      (u, c) => (this.is(u) ? t.success(u) : t.failure(u, c)),
      t.identity,
    );
  }
}
export type DefinedC = {} & DefinedType;
export const Defined: DefinedC = new DefinedType();

export const schemaId =
  'https://schemas.maas.global/maas-backend/customers/personalDataCatalog.json';

// RegionRestriction
// Restrict to the specified list of regions
export type RegionRestriction = t.Branded<
  Array<Region_ad49_.RegionId>,
  RegionRestrictionBrand
>;
export type RegionRestrictionC = t.BrandC<
  t.ArrayC<typeof Region_ad49_.RegionId>,
  RegionRestrictionBrand
>;
export const RegionRestriction: RegionRestrictionC = t.brand(
  t.array(Region_ad49_.RegionId),
  (x): x is t.Branded<Array<Region_ad49_.RegionId>, RegionRestrictionBrand> => true,
  'RegionRestriction',
);
export type RegionRestrictionBrand = {
  readonly RegionRestriction: unique symbol;
};

// DependsOnRestriction
// The purpose of this remains a mystery
export type DependsOnRestriction = t.Branded<
  ({
    name?: string;
    values?: Array<string>;
  } & Record<string, unknown>) & {
    name: Defined;
  },
  DependsOnRestrictionBrand
>;
export type DependsOnRestrictionC = t.BrandC<
  t.IntersectionC<
    [
      t.IntersectionC<
        [
          t.PartialC<{
            name: t.StringC;
            values: t.ArrayC<t.StringC>;
          }>,
          t.RecordC<t.StringC, t.UnknownC>,
        ]
      >,
      t.TypeC<{
        name: typeof Defined;
      }>,
    ]
  >,
  DependsOnRestrictionBrand
>;
export const DependsOnRestriction: DependsOnRestrictionC = t.brand(
  t.intersection([
    t.intersection([
      t.partial({
        name: t.string,
        values: t.array(t.string),
      }),
      t.record(t.string, t.unknown),
    ]),
    t.type({
      name: Defined,
    }),
  ]),
  (
    x,
  ): x is t.Branded<
    ({
      name?: string;
      values?: Array<string>;
    } & Record<string, unknown>) & {
      name: Defined;
    },
    DependsOnRestrictionBrand
  > => true,
  'DependsOnRestriction',
);
export type DependsOnRestrictionBrand = {
  readonly DependsOnRestriction: unique symbol;
};

// PersonalDataCatalogItem
// The purpose of this remains a mystery
export type PersonalDataCatalogItem = t.Branded<
  {
    name?: string;
    type?: string & ('string' | 'ISODate' | 'ISODatetime' | 'ISOCountryAlpha2');
    enum?: Array<string>;
    canShowPlain?: boolean;
    regionRestriction?: RegionRestriction;
    dependsOn?: Array<DependsOnRestriction>;
  } & {
    name: Defined;
    type: Defined;
    canShowPlain: Defined;
  },
  PersonalDataCatalogItemBrand
>;
export type PersonalDataCatalogItemC = t.BrandC<
  t.IntersectionC<
    [
      t.PartialC<{
        name: t.StringC;
        type: t.IntersectionC<
          [
            t.StringC,
            t.UnionC<
              [
                t.LiteralC<'string'>,
                t.LiteralC<'ISODate'>,
                t.LiteralC<'ISODatetime'>,
                t.LiteralC<'ISOCountryAlpha2'>,
              ]
            >,
          ]
        >;
        enum: t.ArrayC<t.StringC>;
        canShowPlain: t.BooleanC;
        regionRestriction: typeof RegionRestriction;
        dependsOn: t.ArrayC<typeof DependsOnRestriction>;
      }>,
      t.TypeC<{
        name: typeof Defined;
        type: typeof Defined;
        canShowPlain: typeof Defined;
      }>,
    ]
  >,
  PersonalDataCatalogItemBrand
>;
export const PersonalDataCatalogItem: PersonalDataCatalogItemC = t.brand(
  t.intersection([
    t.partial({
      name: t.string,
      type: t.intersection([
        t.string,
        t.union([
          t.literal('string'),
          t.literal('ISODate'),
          t.literal('ISODatetime'),
          t.literal('ISOCountryAlpha2'),
        ]),
      ]),
      enum: t.array(t.string),
      canShowPlain: t.boolean,
      regionRestriction: RegionRestriction,
      dependsOn: t.array(DependsOnRestriction),
    }),
    t.type({
      name: Defined,
      type: Defined,
      canShowPlain: Defined,
    }),
  ]),
  (
    x,
  ): x is t.Branded<
    {
      name?: string;
      type?: string & ('string' | 'ISODate' | 'ISODatetime' | 'ISOCountryAlpha2');
      enum?: Array<string>;
      canShowPlain?: boolean;
      regionRestriction?: RegionRestriction;
      dependsOn?: Array<DependsOnRestriction>;
    } & {
      name: Defined;
      type: Defined;
      canShowPlain: Defined;
    },
    PersonalDataCatalogItemBrand
  > => true,
  'PersonalDataCatalogItem',
);
export type PersonalDataCatalogItemBrand = {
  readonly PersonalDataCatalogItem: unique symbol;
};

// PersonalDataCatalog
// The default export. More information at the top.
export type PersonalDataCatalog = t.Branded<unknown, PersonalDataCatalogBrand>;
export type PersonalDataCatalogC = t.BrandC<t.UnknownC, PersonalDataCatalogBrand>;
export const PersonalDataCatalog: PersonalDataCatalogC = t.brand(
  t.unknown,
  (x): x is t.Branded<unknown, PersonalDataCatalogBrand> => true,
  'PersonalDataCatalog',
);
export type PersonalDataCatalogBrand = {
  readonly PersonalDataCatalog: unique symbol;
};

export default PersonalDataCatalog;

// Success
